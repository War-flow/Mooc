@page "/session/{SessionId:int}"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Authorization
@using Mooc.Data
@using Microsoft.EntityFrameworkCore
@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Components.Forms
@using Mooc.Services
@using Microsoft.AspNetCore.WebUtilities
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject NavigationManager NavigationManager
@attribute [Authorize(Policy = "VoirCours")]
@attribute [StreamRendering]

<PageTitle>@(session?.Title ?? "Cours")</PageTitle>

@if (isLoading)
{
    <div class="container mt-4">
        <div class="d-flex justify-content-center">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Chargement...</span>
            </div>
        </div>
    </div>
}
else if (errorMessage != null)
{
    <div class="container mt-4">
        <div class="alert alert-danger">
            <i class="bi bi-exclamation-triangle me-2"></i>
            @errorMessage
        </div>
        <button class="btn btn-primary" @onclick="ReloadData">
            <i class="bi bi-arrow-clockwise me-1"></i>
            Réessayer
        </button>
    </div>
}
else if (session == null)
{
    <div class="container mt-4">
        <div class="alert alert-warning">
            <i class="bi bi-info-circle me-2"></i>
            Session introuvable.
        </div>
    </div>
}
else
{
    @* Ajout d'un header moderne *@
    <div class="page-header">
        <div class="container">
            <h1 class="page-title">@session?.Title</h1>
            <p class="page-subtitle">
                @session?.Description
            </p>
            <div>
                <span class="badge @(IsSessionEnded() ? "bg-secondary" : IsSessionActive() ? "bg-success" : "bg-warning") me-2">
                    @(IsSessionEnded() ? "Session terminée" : IsSessionActive() ? "Session en cours" : "À venir")
                </span>
                <span class="badge bg-info">@coursList.Count cours</span>
            </div>
        </div>
    </div>

    <div class="container mt-4">
        @if (IsSessionEnded())
        {
            <div class="alert alert-warning mb-4">
                <i class="bi bi-exclamation-triangle me-2"></i>
                <strong>Session terminée</strong> - Cette session s'est terminée le @session.EndDate.ToString("dd/MM/yyyy").
            </div>
        }

        <div class="courses-grid">
            @foreach (var cours in orderedCoursList)
            {
                <div class="course-card">
                    <div class="course-header">
                        <div class="course-status">
                            <span class="badge @(cours.IsPublished ? "bg-success" : "bg-secondary")">
                                @(cours.IsPublished ? "Disponible" : "À venir")
                            </span>
                            @if (cours.IsRequired)
                            {
                                <span class="badge bg-warning">Obligatoire</span>
                            }
                            <span class="badge @GetCourseStatusBadgeClass(cours.Id)">
                                @GetCourseCompletionStatus(cours.Id)
                            </span>
                        </div>
                    </div>
                    <div class="course-content">
                        <div class="course-title">@cours.Title</div>
                        <div class="course-description">@GetTruncatedDescription(cours.Description)</div>
                        <div class="course-meta">
                            <div class="course-duration">
                                <i class="bi bi-clock me-1"></i> @cours.Duration min
                            </div>
                            <div class="course-updated">
                                <i class="bi bi-calendar me-1"></i> Mise à jour : @cours.UpdatedAt.ToString("dd/MM/yyyy")
                            </div>
                        </div>
                    </div>
                    <div class="course-actions">
                        <div class="btn-group w-100">
                            <button class="btn btn-outline-primary"
                                    @onclick="() => VoirCours(cours.Id)"
                                    disabled="@(!cours.IsPublished)">
                                <i class="bi bi-play-circle-fill me-1"></i>
                                @(cours.IsPublished ? "Démarrer" : "Bientôt")
                            </button>
                        </div>
                    </div>
                </div>
            }

            @if (!coursList.Any())
            {
                <div class="empty-state mt-4">
                    <div class="empty-state-icon"><i class="bi bi-emoji-frown"></i></div>
                    <div class="empty-state-title">Aucun cours disponible</div>
                    <div class="empty-state-text">
                        Cette session ne contient pas encore de cours publiés.
                    </div>
                </div>
            }
        </div>

        <div class="row mt-4">
            <div class="col-md-8 mx-auto">
                <div class="card bg-light">
                    <div class="card-body">
                        <h6 class="card-title">Progression des cours</h6>
                        <div class="progress mb-1" style="height: 8px;">
                            <div class="progress-bar bg-success" role="progressbar"
                                 style="width: @(progressPercentage)%"
                                 aria-valuenow="@progressPercentage"
                                 aria-valuemin="0"
                                 aria-valuemax="100">
                            </div>
                        </div>
                        <small class="text-muted">
                            @completedCoursCount sur @coursList.Count cours terminés
                        </small>
                    </div>
                </div>
            </div>
        </div>
    </div>
}

@code {
    [Parameter] public int SessionId { get; set; }

    private Session? session;
    private List<Cours> coursList = new();
    private bool isLoading = true;
    private string? errorMessage;
    private Timer? refreshTimer;
    private Timer? courseProgressTimer; // Nouveau timer pour les progrès des cours

    // Nouveau dictionnaire pour tracker les progrès des cours
    private Dictionary<int, Services.CourseProgress> courseProgresses = new();

    // Injection du service
    @inject CourseStateService CourseStateService

    // Propriétés calculées pour améliorer les performances
    private IEnumerable<Cours> orderedCoursList => coursList.OrderBy(c => c.Order);
    private int publishedCoursCount => coursList.Count(c => c.IsPublished);
    private int totalDuration => coursList.Sum(c => c.Duration);
    private int completedCoursCount => courseProgresses.Count(kvp => kvp.Value.IsCompleted);
    private int progressPercentage => coursList.Any() ? (completedCoursCount * 100) / coursList.Count : 0;

    protected override async Task OnInitializedAsync()
    {
        await LoadSessionData();
        await LoadCourseProgresses(); // Charger les progrès des cours
        
        // Démarrer un timer pour vérifier les changements de statut de session toutes les minutes
        refreshTimer = new Timer(async _ => await CheckSessionStatus(), null, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1));
        
        // Nouveau timer pour vérifier les progrès des cours toutes les 30 secondes
        courseProgressTimer = new Timer(async _ => await RefreshCourseProgresses(), null, TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30));
    }

    protected override async Task OnParametersSetAsync()
    {
        // Recharger les données si SessionId change
        await LoadSessionData();
        await LoadCourseProgresses();
    }

    public void Dispose()
    {
        refreshTimer?.Dispose();
        courseProgressTimer?.Dispose(); // Nouveau
    }

    // Nouvelle méthode pour charger les progrès des cours
    private async Task LoadCourseProgresses()
    {
        try
        {
            courseProgresses.Clear();
            
            foreach (var cours in coursList)
            {
                var progress = await CourseStateService.GetOrCreateProgressAsync(cours.Id);
                courseProgresses[cours.Id] = progress;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du chargement des progrès: {ex.Message}");
        }
    }

    // Nouvelle méthode pour rafraîchir les progrès des cours
    private async Task RefreshCourseProgresses()
    {
        if (coursList.Any())
        {
            var previousCompletedCount = completedCoursCount;
            await LoadCourseProgresses();
            
            // Si le nombre de cours complétés a changé, rafraîchir l'interface
            if (completedCoursCount != previousCompletedCount)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    // Méthode pour obtenir le statut d'un cours spécifique
    private string GetCourseCompletionStatus(int coursId)
    {
        if (courseProgresses.TryGetValue(coursId, out var progress))
        {
            if (progress.IsCompleted)
            {
                return "Terminé";
            }
            else if (progress.CompletedBlocks.Any())
            {
                return "En cours";
            }
        }
        return "Non commencé";
    }
    
    // Méthode pour obtenir la classe CSS du badge de statut
    private string GetCourseStatusBadgeClass(int coursId)
    {
        return GetCourseCompletionStatus(coursId) switch
        {
            "Terminé" => "bg-success",
            "En cours" => "bg-warning",
            _ => "bg-secondary"
        };
    }

    private async Task CheckSessionStatus()
    {
        // Vérifier si le statut de la session a changé
        if (session != null)
        {
            var currentTime = DateTime.Now;
            var wasActive = IsSessionActive();
            var wasEnded = IsSessionEnded();

            // Recharger les données de session pour détecter les changements
            using var context = await DbContextFactory.CreateDbContextAsync();
            var updatedSession = await context.Sessions
                .Include(s => s.Courses)
                .FirstOrDefaultAsync(s => s.Id == SessionId);

            if (updatedSession != null)
            {
                var sessionChanged = session.EndDate != updatedSession.EndDate || 
                                   session.StartDate != updatedSession.StartDate ||
                                   session.IsActive != updatedSession.IsActive;

                if (sessionChanged)
                {
                    session = updatedSession;
                    coursList = session.Courses?.ToList() ?? new List<Cours>();
                    await LoadCourseProgresses(); // Recharger les progrès aussi
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
    }

// Ajout de la méthode manquante pour tronquer la description
 private string GetTruncatedDescription(string? description, int maxLength = 80)
  {
   if (string.IsNullOrWhiteSpace(description))
   return string.Empty;
   if (description.Length <= maxLength)
   return description;
   return description.Substring(0, maxLength) + "...";
  }

    private async Task LoadSessionData()
    {
        try
        {
            isLoading = true;
            errorMessage = null;

            using var context = await DbContextFactory.CreateDbContextAsync();
            session = await context.Sessions
                .Include(s => s.Courses)
                .FirstOrDefaultAsync(s => s.Id == SessionId);

            if (session?.Courses != null)
            {
                coursList = session.Courses.ToList();
            }
            else
            {
                coursList = new List<Cours>();
            }
        }
        catch (Exception ex)
        {
            errorMessage = "Erreur lors du chargement de la session. Veuillez réessayer.";
            // Log l'erreur si vous avez un système de logging
        }
        finally
        {
            isLoading = false;
        }
    }

    // Ajout de la méthode manquante pour vérifier si la session est terminée
    private bool IsSessionEnded()
    {
        return session != null && DateTime.Now > session.EndDate;
    }

    // Ajout de la méthode pour vérifier si la session est active
    private bool IsSessionActive()
    {
        return session != null && DateTime.Now >= session.StartDate && DateTime.Now <= session.EndDate && session.IsActive;
    }

    private async Task ReloadData()
    {

        await LoadSessionData();
        await LoadCourseProgresses();
    }

    // Ajout de la méthode manquante pour corriger CS0103
    private void VoirCours(int coursId)
    {
        // Redirige vers la page du cours avec la route correcte
        NavigationManager.NavigateTo($"/Cours/View/{coursId}");
    }
}