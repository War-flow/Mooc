@page "/session/{SessionId:int}"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Authorization
@using Mooc.Data
@using Microsoft.EntityFrameworkCore
@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Components.Forms
@using Mooc.Services
@using Microsoft.AspNetCore.WebUtilities
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject NavigationManager NavigationManager
@attribute [Authorize(Policy = "VoirCours")]
@attribute [StreamRendering]

<PageTitle>@(session?.Title ?? "Cours")</PageTitle>

@if (isLoading)
{
    <div class="container mt-4">
        <div class="d-flex justify-content-center">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Chargement...</span>
            </div>
        </div>
    </div>
}
else if (errorMessage != null)
{
    <div class="container mt-4">
        <div class="alert alert-danger">
            <i class="bi bi-exclamation-triangle me-2"></i>
            @errorMessage
        </div>
        <button class="btn btn-primary" @onclick="ReloadData">
            <i class="bi bi-arrow-clockwise me-1"></i>
            Réessayer
        </button>
    </div>
}
else if (session == null)
{
    <div class="container mt-4">
        <div class="alert alert-warning">
            <i class="bi bi-info-circle me-2"></i>
            Session introuvable.
        </div>
    </div>
}
else
{
    @* Ajout d'un header moderne *@
    <div class="page-header header-waves ocean header-animated">
        <div class="container">
            <h1 class="page-title typewriter">@session?.Title</h1>
            <p class="page-subtitle">
                @session?.Description
            </p>
            <div>
                <span class="badge @(IsSessionEnded() ? "bg-secondary" : IsSessionActive() ? "bg-success" : "bg-warning") me-2">
                    @(IsSessionEnded() ? "Session terminée" : IsSessionActive() ? "Session en cours" : "À venir")
                </span>
                <span class="badge bg-info">@coursList.Count cours</span>
                @* **NOUVEAU**: Affichage du score total de la session *@
                @if (sessionTotalScore > 0)
                {
                    <span class="badge bg-warning">
                        <i class="bi bi-trophy me-1"></i>
                        @sessionTotalScore pts
                    </span>
                }
            </div>
        </div>
    </div>

    <div class="container mt-4">
        @if (IsSessionEnded())
        {
            <div class="alert alert-warning mb-4">
                <i class="bi bi-exclamation-triangle me-2"></i>
                <strong>Session terminée</strong> - Cette session s'est terminée le @session.EndDate.ToString("dd/MM/yyyy").
            </div>
        }

        @* **NOUVEAU: Affichage du message d'erreur temporaire** *@
        @if (!string.IsNullOrEmpty(tempErrorMessage))
        {
            <div class="alert alert-info mb-4" role="alert">
                <i class="bi bi-info-circle me-2"></i>
                @((MarkupString)tempErrorMessage)
            </div>
        }

        <div class="courses-grid">
            @foreach (var cours in orderedCoursList)
            {
                <div class="course-card">
                    <div class="course-header">
                        <div class="course-status">
                            <span class="badge @GetCourseStatusBadgeClass(cours.Id)">
                                @GetCourseCompletionStatus(cours.Id)
                            </span>
                        </div>
                        @* **NOUVEAU**: Affichage du score du cours *@
                        @if (courseScores.ContainsKey(cours.Id) && courseScores[cours.Id].TotalEarnedPoints > 0)
                        {
                            <div class="course-score">
                                <span class="badge bg-success">
                                    <i class="bi bi-star-fill me-1"></i>
                                    @courseScores[cours.Id].TotalEarnedPoints/@courseScores[cours.Id].TotalPossiblePoints pts
                                </span>
                                <small class="text-muted d-block mt-1">
                                    @courseScores[cours.Id].ScorePercentage.ToString("F1")%
                                </small>
                            </div>
                        }
                    </div>
                    <div class="course-content">
                        <div class="course-title">@cours.Title</div>
                        <div class="course-description">@GetTruncatedDescription(cours.Description)</div>
                        
                        @* **NOUVEAU**: Détails du score si disponible *@
                        @if (courseScores.ContainsKey(cours.Id) && courseScores[cours.Id].QuizCount > 0)
                        {
                            <div class="course-score-details mt-2">
                                <small class="text-muted">
                                    <i class="bi bi-check-circle me-1"></i>
                                    @courseScores[cours.Id].CorrectAnswers/@courseScores[cours.Id].QuizCount quiz réussis
                                </small>
                                <div class="performance-level mt-1">
                                    <span class="badge @GetPerformanceBadgeClass(courseScores[cours.Id].OverallLevel)">
                                        @GetPerformanceLevelText(courseScores[cours.Id].OverallLevel)
                                    </span>
                                </div>
                            </div>
                        }

                        <div class="course-meta">
                            <div class="course-updated">
                                <i class="bi bi-calendar me-1"></i> Mise à jour : @cours.UpdatedAt.ToString("dd/MM/yyyy")
                            </div>
                        </div>
                    </div>
                    <div class="course-actions">
                        <div class="btn-group w-100">
                            <button class="btn btn-outline-primary"
                                 @onclick="() => VoirCours(cours.Id)"
                                 disabled="@(!cours.IsPublished || IsSessionEnded() || GetCourseCompletionStatus(cours.Id) == "Terminé")">
                                 <i class="bi bi-play-circle-fill me-1"></i>
                                 @(GetCourseCompletionStatus(cours.Id) == "Terminé" ? "Terminé" :
                                 cours.IsPublished ? "Démarrer" : "Bientôt")
                            </button>
                        </div>
                    </div>
                </div>
            }

            @if (!coursList.Any())
            {
                <div class="empty-state mt-4">
                    <div class="empty-state-icon"><i class="bi bi-emoji-frown"></i></div>
                    <div class="empty-state-title">Aucun cours disponible</div>
                    <div class="empty-state-text">
                        Cette session ne contient pas encore de cours publiés.
                    </div>
                </div>
            }
        </div>

        <div class="row mt-4">
            <div class="col-md-8 mx-auto">
                <div class="card bg-light">
                    <div class="card-body">
                        <h6 class="card-title">Progression des cours</h6>
                        <div class="progress mb-1" style="height: 8px;">
                            <div class="progress-bar bg-success" role="progressbar"
                                 style="width: @(progressPercentage)%"
                                 aria-valuenow="@progressPercentage"
                                 aria-valuemin="0"
                                 aria-valuemax="100">
                            </div>
                        </div>
                        <small class="text-muted">
                            @completedCoursCount sur @coursList.Count cours terminés
                        </small>
                        
                        @* **NOUVEAU**: Affichage du score global de la session *@
                        @if (sessionTotalScore > 0 || sessionMaxScore > 0)
                        {
                            <div class="mt-3">
                                <h6 class="card-title">Score global de la session</h6>
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <span class="fs-4 fw-bold text-primary">@sessionTotalScore</span>
                                        <span class="text-muted">/ @sessionMaxScore points</span>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                </div>
            </div>
        </div>
    </div>
}

@code {
    [Parameter] public int SessionId { get; set; }

    private Session? session;
    private List<Cours> coursList = new();
    private bool isLoading = true;
    private string? errorMessage;
    private string? tempErrorMessage; // Nouveau: pour les erreurs temporaires
    private Timer? refreshTimer;
    private Timer? courseProgressTimer;
    private Timer? errorMessageTimer; // Nouveau: pour effacer les erreurs temporaires

    // Nouveau dictionnaire pour tracker les progrès des cours
    private Dictionary<int, Services.CourseProgress> courseProgresses = new();
    
    // **CORRECTION**: Initialisation explicite des dictionnaires pour les scores
    private Dictionary<int, CourseScoreResult> courseScores = new Dictionary<int, CourseScoreResult>();
    private int sessionTotalScore = 0;
    private int sessionMaxScore = 0;
    private double sessionScorePercentage = 0;

    // Injection du service
    @inject CourseStateService CourseStateService

    // Propriétés calculées pour améliorer les performances
    private IEnumerable<Cours> orderedCoursList => coursList.OrderBy(c => c.Order);
    private int publishedCoursCount => coursList.Count(c => c.IsPublished);
    private int completedCoursCount => courseProgresses.Count(kvp => kvp.Value.IsCompleted);
    private int progressPercentage => coursList.Any() ? (completedCoursCount * 100) / coursList.Count : 0;

    protected override async Task OnInitializedAsync()
    {
        // **AJOUT**: Initialisation explicite des dictionnaires au cas où
        courseProgresses ??= new Dictionary<int, Services.CourseProgress>();
        courseScores ??= new Dictionary<int, CourseScoreResult>();
        
        await LoadSessionData();
        await LoadCourseProgresses(); // Charger les progrès des cours
        await LoadCourseScores(); // **NOUVEAU**: Charger les scores des cours
        
        // Démarrer un timer pour vérifier les changements de statut de session toutes les minutes
        refreshTimer = new Timer(async _ => await CheckSessionStatus(), null, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1));
        
        // Nouveau timer pour vérifier les progrès des cours toutes les 30 secondes
        courseProgressTimer = new Timer(async _ => await RefreshCourseProgresses(), null, TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30));
    }

    protected override async Task OnParametersSetAsync()
    {
        // Recharger les données si SessionId change
        await LoadSessionData();
        await LoadCourseProgresses();
        await LoadCourseScores(); // **NOUVEAU**
    }

    public void Dispose()
    {
        refreshTimer?.Dispose();
        courseProgressTimer?.Dispose();
        errorMessageTimer?.Dispose(); // Nouveau
    }

    // **NOUVELLE MÉTHODE**: Charger les scores des cours
    private async Task LoadCourseScores()
    {
        try
        {
            // **CORRECTION**: Vérification et initialisation si nécessaire
            courseScores ??= new Dictionary<int, CourseScoreResult>();
            courseScores.Clear();
            
            sessionTotalScore = 0;
            sessionMaxScore = 0;
            
            foreach (var cours in coursList)
            {
                var scoreResult = await CourseStateService.CalculateCourseScoreAsync(cours.Id);
                courseScores[cours.Id] = scoreResult;
                
                sessionTotalScore += scoreResult.TotalEarnedPoints;
                sessionMaxScore += scoreResult.TotalPossiblePoints;
            }
            
            // Calculer le pourcentage global
            sessionScorePercentage = sessionMaxScore > 0 ? (double)sessionTotalScore / sessionMaxScore * 100 : 0;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du chargement des scores: {ex.Message}");
            // **AJOUT**: Réinitialiser les scores en cas d'erreur
            courseScores ??= new Dictionary<int, CourseScoreResult>();
            sessionTotalScore = 0;
            sessionMaxScore = 0;
            sessionScorePercentage = 0;
        }
    }

    // Nouvelle méthode pour charger les progrès des cours
    private async Task LoadCourseProgresses()
    {
        try
        {
            // **AJOUT**: Vérification et initialisation si nécessaire
            courseProgresses ??= new Dictionary<int, Services.CourseProgress>();
            courseProgresses.Clear();
            
            foreach (var cours in coursList)
            {
                var progress = await CourseStateService.GetOrCreateProgressAsync(cours.Id);
                courseProgresses[cours.Id] = progress;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du chargement des progrès: {ex.Message}");
            // **AJOUT**: Réinitialiser les progrès en cas d'erreur
            courseProgresses ??= new Dictionary<int, Services.CourseProgress>();
        }
    }

    // Nouvelle méthode pour rafraîchir les progrès des cours
    private async Task RefreshCourseProgresses()
    {
        if (coursList.Any())
        {
            var previousCompletedCount = completedCoursCount;
            await LoadCourseProgresses();
            await LoadCourseScores(); // **NOUVEAU**: Rafraîchir les scores aussi
            
            // Si le nombre de cours complétés a changé, rafraîchir l'interface
            if (completedCoursCount != previousCompletedCount)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    // **NOUVELLES MÉTHODES**: Helper pour l'affichage des performances
    private string GetPerformanceBadgeClass(CoursePerformanceLevel level)
    {
        return level switch
        {
            CoursePerformanceLevel.Excellent => "bg-success",
            CoursePerformanceLevel.Good => "bg-info",
            CoursePerformanceLevel.Average => "bg-warning",
            _ => "bg-secondary"
        };
    }
    
    private string GetPerformanceLevelText(CoursePerformanceLevel level)
    {
        return level switch
        {
            CoursePerformanceLevel.Excellent => "Excellent",
            CoursePerformanceLevel.Good => "Bien",
            CoursePerformanceLevel.Average => "Moyen",
            _ => "Non évalué"
        };
    }

    // Méthode pour obtenir le statut d'un cours spécifique
    private string GetCourseCompletionStatus(int coursId)
    {
        if (courseProgresses.TryGetValue(coursId, out var progress))
        {
            if (progress.IsCompleted)
            {
                return "Terminé";
            }
            else if (progress.CompletedBlocks.Any())
            {
                return "En cours";
            }
        }
        return "Non commencé";
    }
    
    // Méthode pour obtenir la classe CSS du badge de statut
    private string GetCourseStatusBadgeClass(int coursId)
    {
        return GetCourseCompletionStatus(coursId) switch
        {
            "Terminé" => "bg-success",
            "En cours" => "bg-warning",
            _ => "bg-secondary"
        };
    }

    private async Task CheckSessionStatus()
    {
        // Vérifier si le statut de la session a changé
        if (session != null)
        {
            var currentTime = DateTime.Now;
            var wasActive = IsSessionActive();
            var wasEnded = IsSessionEnded();

            // Recharger les données de session pour détecter les changements
            using var context = await DbContextFactory.CreateDbContextAsync();
            var updatedSession = await context.Sessions
                .Include(s => s.Courses)
                .FirstOrDefaultAsync(s => s.Id == SessionId);

            if (updatedSession != null)
            {
                var sessionChanged = session.EndDate != updatedSession.EndDate || 
                                   session.StartDate != updatedSession.StartDate ||
                                   session.IsActive != updatedSession.IsActive;

                if (sessionChanged)
                {
                    session = updatedSession;
                    coursList = session.Courses?.ToList() ?? new List<Cours>();
                    await LoadCourseProgresses(); // Recharger les progrès aussi
                    await LoadCourseScores(); // **NOUVEAU**: Recharger les scores aussi
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
    }

// Ajout de la méthode manquante pour tronquer la description
 private string GetTruncatedDescription(string? description, int maxLength = 80)
  {
   if (string.IsNullOrWhiteSpace(description))
   return string.Empty;
   if (description.Length <= maxLength)
   return description;
   return description.Substring(0, maxLength) + "...";
  }

    private async Task LoadSessionData()
    {
        try
        {
            isLoading = true;
            errorMessage = null;

            using var context = await DbContextFactory.CreateDbContextAsync();
            session = await context.Sessions
                .Include(s => s.Courses)
                .FirstOrDefaultAsync(s => s.Id == SessionId);

            if (session?.Courses != null)
            {
                coursList = session.Courses.ToList();
            }
            else
            {
                coursList = new List<Cours>();
            }
        }
        catch (Exception ex)
        {
            errorMessage = "Erreur lors du chargement de la session. Veuillez réessayer.";
            // Log l'erreur si vous avez un système de logging
        }
        finally
        {
            isLoading = false;
        }
    }

    // Ajout de la méthode manquante pour vérifier si la session est terminée
    private bool IsSessionEnded()
    {
        return session != null && DateTime.Now > session.EndDate;
    }

    // Ajout de la méthode pour vérifier si la session est active
    private bool IsSessionActive()
    {
        return session != null && DateTime.Now >= session.StartDate && DateTime.Now <= session.EndDate && session.IsActive;
    }

    private async Task ReloadData()
    {

        await LoadSessionData();
        await LoadCourseProgresses();
    }

    // Ajout de la méthode manquante pour corriger CS0103
    private void VoirCours(int coursId)
    {
        // Vérifier si la session est terminée
        if (IsSessionEnded())
        {
            tempErrorMessage = $"Impossible de démarrer le cours. Cette session s'est terminée le {session?.EndDate.ToString("dd/MM/yyyy")}.<br>Vous serez redirigé vers la page d'accueil dans quelques secondes.";
            
            // Programmer l'effacement du message après 5 secondes
            errorMessageTimer?.Dispose();
            errorMessageTimer = new Timer(_ => {
                tempErrorMessage = null;
                NavigationManager.NavigateTo("/"); // Rediriger vers la page d'accueil
            }, null, TimeSpan.FromSeconds(5), Timeout.InfiniteTimeSpan);
            
            StateHasChanged();
            return;
        }

        // **NOUVEAU: Vérifier si le cours est déjà terminé**
        if (GetCourseCompletionStatus(coursId) == "Terminé")
        {
            tempErrorMessage = "Ce cours est déjà terminé. Vous ne pouvez pas le redémarrer.";
            
            // Programmer l'effacement du message après 3 secondes
            errorMessageTimer?.Dispose();
            errorMessageTimer = new Timer(_ => {
                tempErrorMessage = null;
                InvokeAsync(StateHasChanged);
            }, null, TimeSpan.FromSeconds(3), Timeout.InfiniteTimeSpan);
            
            StateHasChanged();
            return;
        }

        // Vérifier si le cours est publié
        var cours = coursList.FirstOrDefault(c => c.Id == coursId);
        if (cours == null || !cours.IsPublished)
        {
            tempErrorMessage = "Ce cours n'est pas encore disponible.";
            
            // Programmer l'effacement du message après 5 secondes
            errorMessageTimer?.Dispose();
            errorMessageTimer = new Timer(_ => {
                tempErrorMessage = null;
                InvokeAsync(StateHasChanged);
            }, null, TimeSpan.FromSeconds(5), Timeout.InfiniteTimeSpan);
            
            StateHasChanged();
            return;
        }

        // Si tout est OK, naviguer vers le cours
        NavigationManager.NavigateTo($"/Cours/View/{coursId}");
    }
}