@using Microsoft.AspNetCore.Components.Forms
@using Mooc.Services
@using System.IO
@inject FileUploadService FileUploadService
@inject IJSRuntime JSRuntime

<div class="file-block @GetTypeClass()" @attributes="AdditionalAttributes">
    <h4 class="file-title">
        @if (IsEditing)
        {
            <InputText class="form-control" @bind-Value="Block.Title" placeholder="Titre (optionnel)" />
            <ValidationMessage For="@(() => Block.Title)" />
        }
        else if (!string.IsNullOrEmpty(Block.Title))
        {
            @Block.Title
        }
    </h4>
    <div class="file-content">
        @if (IsEditing)
        {
            <div class="mb-3">
                <InputFile OnChange="OnFilesSelected" accept="@AllowedFileTypes" class="form-control" multiple />
                <small class="form-text text-muted">Formats acceptés : @AllowedFileTypes (max @(MaxFileSizeMB) MB par fichier)</small>
                <ValidationMessage For="@(() => Block.FileUrls)" />
            </div>
            
            <!-- Affichage des erreurs d'upload individuelles -->
            @if (fileUploadResults.Any(r => !r.Success))
            {
                <div class="upload-errors mb-3">
                    @foreach (var result in fileUploadResults.Where(r => !r.Success))
                    {
                        <div class="alert alert-danger file-error">
                            <i class="bi bi-exclamation-triangle"></i>
                            <strong>@result.FileName :</strong> @result.ErrorMessage
                            <button type="button" class="btn-close btn-close-white ms-auto" @onclick="() => RemoveUploadResult(result)"></button>
                        </div>
                    }
                </div>
            }

            @if (isUploading)
            {
                <div class="upload-progress mb-3">
                    <div class="mb-2">
                        <div class="d-flex justify-content-between">
                            <small class="text-muted">Progression globale</small>
                            <small class="text-muted">@completedFiles/@totalFiles fichiers</small>
                        </div>
                        <div class="progress">
                            <div class="progress-bar" role="progressbar" style="width: @globalProgress%" aria-valuenow="@globalProgress" aria-valuemin="0" aria-valuemax="100">
                                @globalProgress%
                            </div>
                        </div>
                    </div>
                    
                    @if (!string.IsNullOrEmpty(currentFileName))
                    {
                        <div class="current-file-progress">
                            <div class="d-flex justify-content-between">
                                <small class="text-muted">@currentFileName</small>
                                <small class="text-muted">@currentFileProgress%</small>
                            </div>
                            <div class="progress progress-sm">
                                <div class="progress-bar bg-info" role="progressbar" style="width: @currentFileProgress%" aria-valuenow="@currentFileProgress" aria-valuemin="0" aria-valuemax="100"></div>
                            </div>
                        </div>
                    }
                </div>
            }

            @if (GetAllFileUrls().Any())
            {
                <div class="mb-2">
                    <span class="me-2">Fichiers actuels :</span>
                    <div class="file-list">
                        @foreach (var fileUrl in GetAllFileUrls())
                        {
                            <div class="d-flex align-items-center mb-1 file-item @GetFileStatusClass(fileUrl)">
                                <div class="file-icon @GetFileIconClass(fileUrl)"></div>
                                <a href="@fileUrl" target="_blank" class="flex-grow-1">@Path.GetFileName(fileUrl)</a>
                                @if (IsFileUploading(fileUrl))
                                {
                                    <div class="spinner-border spinner-border-sm me-2" role="status">
                                        <span class="visually-hidden">Chargement...</span>
                                    </div>
                                }
                                else if (HasFileError(fileUrl))
                                {
                                    <i class="bi bi-exclamation-circle text-danger me-2" title="Erreur de téléchargement"></i>
                                }
                                else
                                {
                                    <i class="bi bi-check-circle text-success me-2" title="Téléchargé avec succès"></i>
                                }
                                <button type="button" class="btn-block btn-cancel btn-sm" @onclick="() => RemoveFile(fileUrl)">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>
                        }
                    </div>
                </div>
            }
        }
        else if (GetAllFileUrls().Any())
        {
            <div class="file-list">
                @foreach (var fileUrl in GetAllFileUrls())
                {
                    <div class="d-flex align-items-center mb-2">
                        <div class="file-icon @GetFileIconClass(fileUrl) me-2"></div>
                        <a href="@fileUrl" target="_blank" class="file-link">
                            <span class="file-name">@Path.GetFileName(fileUrl)</span>
                            <i class="bi bi-download ms-2"></i>
                        </a>
                    </div>
                }
            </div>
        }
        else
        {
            <div class="alert alert-info">
                Aucun fichier disponible. Cliquez sur "Modifier" pour ajouter.
            </div>
        }
    </div>
    <div class="block-controls">
        <button type="button" class="btn-block btn-valid" @onclick="ToggleEdit">
            <i class="bi @(IsEditing ? "floppy" : "bi-pencil")"></i>
            @(IsEditing ? "Enregistrer" : "Modifier")
        </button>
        @if (!IsEditing)
        {
            <button type="button" class="btn-block btn-cancel" @onclick="RequestDelete" title="Supprimer ce bloc">
                <i class="bi bi-trash"></i> Supprimer
            </button>
        }

        @if (IsEditing)
        {
            <button class="btn-block btn-cancel" @onclick="CancelEdit">
                <i class="bi bi-x-lg"></i> Annuler
            </button>
        }
    </div>
</div>

@code {
    [Parameter]
    public CourBuilder.CoursBlock Block { get; set; } = default!;

    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnBlockChanged { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnDeleteRequested { get; set; }

    // Classe pour gérer les résultats d'upload individuels
    private class FileUploadResult
    {
        public string FileName { get; set; } = string.Empty;
        public bool Success { get; set; }
        public string? FileUrl { get; set; }
        public string? ErrorMessage { get; set; }
        public bool IsUploading { get; set; }
        public int Progress { get; set; }
    }

    private bool IsEditing { get; set; }
    private string? originalTitle;
    private List<string> originalFileUrls = new();
    private bool isUploading = false;
    private int globalProgress = 0;
    private int currentFileProgress = 0;
    private int completedFiles = 0;
    private int totalFiles = 0;
    private string currentFileName = string.Empty;
    private List<FileUploadResult> fileUploadResults = new();

    private const string AllowedFileTypes = ".pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.zip,.txt";
    private const int MaxFileSizeMB = 10;
    private const long MaxFileSizeBytes = MaxFileSizeMB * 1024 * 1024;

    protected override void OnInitialized()
    {
        originalTitle = Block.Title;
        originalFileUrls = new List<string>(GetAllFileUrls());
        base.OnInitialized();
    }

    private List<string> GetAllFileUrls()
    {
        var urls = new List<string>();
        
        if (!string.IsNullOrEmpty(Block.FileUrl))
        {
            urls.Add(Block.FileUrl);
        }
        
        if (Block.FileUrls != null)
        {
            urls.AddRange(Block.FileUrls);
        }
        
        return urls.Distinct().ToList();
    }

    private string GetTypeClass()
    {
        var classes = new List<string> { "file-block" };

        if (!GetAllFileUrls().Any())
        {
            classes.Add("empty");
        }

        return string.Join(" ", classes);
    }

    private string GetFileIconClass(string fileUrl)
    {
        if (string.IsNullOrEmpty(fileUrl))
            return "bi-file";

        string extension = Path.GetExtension(fileUrl).ToLowerInvariant();

        return extension switch
        {
            ".pdf" => "bi-file-earmark-pdf",
            ".doc" or ".docx" => "bi-file-earmark-word",
            ".xls" or ".xlsx" => "bi-file-earmark-excel",
            ".ppt" or ".pptx" => "bi-file-earmark-slides",
            ".zip" => "bi-file-earmark-zip",
            ".txt" => "bi-file-earmark-text",
            _ => "bi-file-earmark"
        };
    }

    private string GetFileStatusClass(string fileUrl)
    {
        var result = fileUploadResults.FirstOrDefault(r => r.FileUrl == fileUrl);
        if (result == null) return string.Empty;

        if (result.IsUploading) return "uploading";
        if (!result.Success) return "error";
        return "success";
    }

    private bool IsFileUploading(string fileUrl)
    {
        return fileUploadResults.Any(r => r.FileUrl == fileUrl && r.IsUploading);
    }

    private bool HasFileError(string fileUrl)
    {
        return fileUploadResults.Any(r => r.FileUrl == fileUrl && !r.Success && !r.IsUploading);
    }

    private async Task OnFilesSelected(InputFileChangeEventArgs e)
    {
        try
        {
            var files = e.GetMultipleFiles(maximumFileCount: 10);
            if (!files.Any())
                return;

            // Réinitialiser les résultats précédents
            fileUploadResults.Clear();

            // Vérifier la taille de chaque fichier
            var invalidFiles = files.Where(f => f.Size > MaxFileSizeBytes).ToList();
            foreach (var invalidFile in invalidFiles)
            {
                fileUploadResults.Add(new FileUploadResult
                {
                    FileName = invalidFile.Name,
                    Success = false,
                    ErrorMessage = $"Fichier trop volumineux ({invalidFile.Size / (1024 * 1024)} MB > {MaxFileSizeMB} MB)"
                });
            }

            var validFiles = files.Except(invalidFiles).ToList();
            if (!validFiles.Any())
            {
                StateHasChanged();
                return;
            }

            isUploading = true;
            totalFiles = validFiles.Count;
            completedFiles = 0;
            globalProgress = 0;

            var newFileUrls = new List<string>();

            foreach (var file in validFiles)
            {
                var uploadResult = new FileUploadResult
                {
                    FileName = file.Name,
                    IsUploading = true,
                    Progress = 0
                };
                fileUploadResults.Add(uploadResult);

                currentFileName = file.Name;
                currentFileProgress = 0;
                StateHasChanged();

                try
                {
                    var progressStream = new ProgressStream(file.OpenReadStream(MaxFileSizeBytes),
                        progress =>
                        {
                            currentFileProgress = progress;
                            uploadResult.Progress = progress;
                            
                            // Calculer le progrès global
                            var totalProgress = fileUploadResults.Where(r => !r.IsUploading).Sum(r => 100) + 
                                              fileUploadResults.Where(r => r.IsUploading).Sum(r => r.Progress);
                            globalProgress = totalProgress / totalFiles;
                            
                            InvokeAsync(StateHasChanged);
                        });

                    var result = await FileUploadService.UploadFileAsync(progressStream, file.Name);
                    
                    uploadResult.IsUploading = false;
                    
                    if (result.Success)
                    {
                        uploadResult.Success = true;
                        uploadResult.FileUrl = result.FileUrl;
                        newFileUrls.Add(result.FileUrl);
                    }
                    else
                    {
                        uploadResult.Success = false;
                        uploadResult.ErrorMessage = result.ErrorMessage ?? "Erreur inconnue";
                    }
                }
                catch (Exception ex)
                {
                    uploadResult.IsUploading = false;
                    uploadResult.Success = false;
                    uploadResult.ErrorMessage = ex.Message;
                }

                completedFiles++;
                StateHasChanged();
            }

            // Ajouter les fichiers téléchargés avec succès
            if (newFileUrls.Any())
            {
                if (Block.FileUrls == null)
                {
                    Block.FileUrls = new List<string>();
                }
                if (!string.IsNullOrEmpty(Block.FileUrl) && !Block.FileUrls.Contains(Block.FileUrl))
                {
                    Block.FileUrls.Add(Block.FileUrl);
                    Block.FileUrl = null;
                }
                Block.FileUrls.AddRange(newFileUrls);
                await OnBlockChanged.InvokeAsync(Block);
            }
        }
        catch (Exception ex)
        {
            fileUploadResults.Add(new FileUploadResult
            {
                FileName = "Erreur générale",
                Success = false,
                ErrorMessage = ex.Message
            });
        }
        finally
        {
            isUploading = false;
            currentFileName = string.Empty;
            StateHasChanged();
        }
    }

    private void RemoveUploadResult(FileUploadResult result)
    {
        fileUploadResults.Remove(result);
        StateHasChanged();
    }

    private void RemoveFile(string fileUrl)
    {
        if (!string.IsNullOrEmpty(Block.FileUrl) && Block.FileUrl == fileUrl)
        {
            Block.FileUrl = null;
        }
        
        Block.FileUrls.Remove(fileUrl);
        
        // Supprimer aussi le résultat d'upload associé
        var uploadResult = fileUploadResults.FirstOrDefault(r => r.FileUrl == fileUrl);
        if (uploadResult != null)
        {
            fileUploadResults.Remove(uploadResult);
        }
        
        StateHasChanged();
    }

    private async Task ToggleEdit()
    {
        if (IsEditing)
        {
            IsEditing = false;
            await OnBlockChanged.InvokeAsync(Block);
        }
        else
        {
            originalTitle = Block.Title;
            originalFileUrls = new List<string>(GetAllFileUrls());
            fileUploadResults.Clear(); // Nettoyer les anciens résultats
            IsEditing = true;
        }
    }

    private void CancelEdit()
    {
        IsEditing = false;
        Block.Title = originalTitle;
        
        Block.FileUrls.Clear();
        Block.FileUrls.AddRange(originalFileUrls.Where(url => !string.IsNullOrEmpty(Block.FileUrl) && url != Block.FileUrl));
        
        fileUploadResults.Clear();
        StateHasChanged();
    }

    private class ProgressStream : Stream
    {
        private readonly Stream _stream;
        private readonly Action<int> _progressChanged;
        private long _totalBytes;
        private long _bytesRead;

        public ProgressStream(Stream stream, Action<int> progressChanged)
        {
            _stream = stream;
            _progressChanged = progressChanged;
            _totalBytes = stream.Length;
            _bytesRead = 0;
        }

        public override bool CanRead => _stream.CanRead;
        public override bool CanSeek => _stream.CanSeek;
        public override bool CanWrite => _stream.CanWrite;
        public override long Length => _stream.Length;
        public override long Position
        {
            get => _stream.Position;
            set => _stream.Position = value;
        }

        public override void Flush() => _stream.Flush();
        public override long Seek(long offset, SeekOrigin origin) => _stream.Seek(offset, origin);
        public override void SetLength(long value) => _stream.SetLength(value);
        public override void Write(byte[] buffer, int offset, int count) => _stream.Write(buffer, offset, count);

        public override int Read(byte[] buffer, int offset, int count)
        {
            int bytesRead = _stream.Read(buffer, offset, count);

            if (bytesRead > 0)
            {
                _bytesRead += bytesRead;
                int progressPercentage = (int)((_bytesRead * 100) / _totalBytes);
                _progressChanged?.Invoke(progressPercentage);
            }

            return bytesRead;
        }
        
        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken = default)
        {
            return ReadAsyncImpl(buffer, offset, count, cancellationToken);

            async Task<int> ReadAsyncImpl(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
            {
                int bytesRead = await _stream.ReadAsync(buffer, offset, count, cancellationToken);
                if (bytesRead > 0)
                {
                    _bytesRead += bytesRead;
                    int progressPercentage = (int)((_bytesRead * 100) / _totalBytes);
                    _progressChanged?.Invoke(progressPercentage);
                }
                return bytesRead;
            }
        }
    }
    
    private async Task RequestDelete(MouseEventArgs args)
    {
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Êtes-vous sûr de vouloir supprimer ce bloc ?");
        if (confirmed)
        {
            await OnDeleteRequested.InvokeAsync(Block);
        }
    }
}