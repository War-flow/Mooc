@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using Mooc.Services
@using Mooc.Data
@using System.Text.Json
@using System.Text.Json.Serialization
@using System.ComponentModel.DataAnnotations
@inject IJSRuntime JSRuntime

<EditForm Model="QuizContent" OnValidSubmit="HandleValidSubmit">
    <DataAnnotationsValidator />
    
    <div class="quiz-block @GetTypeClass() @GetDifficultyClass()" @attributes="AdditionalAttributes">
        <h4 class="quiz-title">
            @if (IsEditing)
            {
                <InputText class="form-control" @bind-Value="QuizContent.Title"
                           placeholder="Titre du quiz" />
                <ValidationMessage For="@(() => QuizContent.Title)" />
            }
            else if (!string.IsNullOrEmpty(QuizContent.Title))
            {
                @QuizContent.Title
                <span class="difficulty-badge ms-2">
                    <i class="@QuizContent.QuizData.GetDifficultyIcon() me-1"></i>
                    @QuizContent.QuizData.Difficulty
                </span>
            }
            else
            {
                <span class="text-muted">Quiz sans titre</span>
            }
        </h4>

        @if (IsEditing)
        {
            <!-- Affichage des erreurs globales -->
            <ValidationSummary />

            <!-- Mode édition du quiz avec validation -->
            <div class="quiz-editor">
                <div class="mb-3">
                    <label class="form-label">
                        Question <span class="text-danger">*</span>
                        <small class="text-muted">(@(QuizContent.QuizData.Question?.Length ?? 0)/500 caractères)</small>
                    </label>

                    <InputTextArea class="form-control"
                                   @bind-Value="QuizContent.QuizData.Question"
                                   rows="3"
                                   maxlength="500"
                                   placeholder="Saisissez votre question..." />
                    <ValidationMessage For="@(() => QuizContent.QuizData.Question)" />
                </div>

                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label class="form-label">Type de quiz</label>
                            <InputSelect class="form-select" @bind-Value="QuizContent.QuizData.Type" @bind-Value:after="OnQuizTypeChanged">
                                <option value="multiple-choice">Choix multiple (une seule réponse)</option>
                                <option value="multiple-select">Choix multiple (plusieurs réponses)</option>
                                <option value="true-false">Vrai/Faux</option>
                            </InputSelect>
                            <ValidationMessage For="@(() => QuizContent.QuizData.Type)" />
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label class="form-label">
                                Niveau de difficulté <span class="text-danger">*</span>
                            </label>
                            <InputSelect class="form-select" @bind-Value="QuizContent.QuizData.Difficulty">
                                @foreach (QuizDifficulty difficulty in Enum.GetValues<QuizDifficulty>())
                                {
                                    <option value="@difficulty">
                                        @GetDifficultyDisplayText(difficulty)
                                    </option>
                                }
                            </InputSelect>
                            <ValidationMessage For="@(() => QuizContent.QuizData.Difficulty)" />
                            <div class="form-text">
                                <small class="text-muted d-flex align-items-center">
                                    <i class="@GetDifficultyIcon(QuizContent.QuizData.Difficulty) me-1"></i>
                                    @GetDifficultyDescription(QuizContent.QuizData.Difficulty)
                                </small>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="mb-3">
                    <label class="form-label">
                        Réponses
                        @if (QuizContent.QuizData.Type == "multiple-select")
                        {
                            <small class="text-muted">(Cochez les bonnes réponses)</small>
                        }
                        else
                        {
                            <small class="text-muted">(Sélectionnez la bonne réponse)</small>
                        }
                    </label>

                    @for (int i = 0; i < QuizContent.QuizData.Options.Count; i++)
                    {
                        var index = i;
                        <div class="input-group mb-2">
                            @if (QuizContent.QuizData.Type == "multiple-select")
                            {
                                <div class="input-group-text">
                                    <InputCheckbox @bind-Value="QuizContent.QuizData.Options[index].IsCorrect" 
                                                   @bind-Value:after="() => OnCorrectAnswerChanged(index)" />
                                </div>
                            }
                            else
                            {
                                <div class="input-group-text">
                                    <input class="form-check-input" type="radio" name="correct-answer-@Block.Order"
                                           checked="@QuizContent.QuizData.Options[index].IsCorrect"
                                           @onclick="@(() => HandleRadioClick(index))" />
                                </div>
                            }
                            <InputText class="form-control"
                                       @bind-Value="QuizContent.QuizData.Options[index].Text"
                                       placeholder="@($"Option {index + 1}")"
                                       maxlength="200" />
                            <button type="button" class="btn btn-outline-danger"
                                    @onclick="() => RemoveOption(index)"
                                    disabled="@(QuizContent.QuizData.Options.Count <= GetMinimumOptions())"
                                    title="Supprimer cette option">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                        <ValidationMessage For="@(() => QuizContent.QuizData.Options[index].Text)" />
                    }

                    <!-- Validation globale des options -->
                    <ValidationMessage For="@(() => QuizContent.QuizData.OptionsValidation)" />

                    <div class="d-flex justify-content-between align-items-center">
                        <button type="button" class="btn btn-outline-primary btn-sm"
                                @onclick="AddOption"
                                disabled="@(QuizContent.QuizData.Options.Count >= 6)">
                            <i class="bi bi-plus"></i> Ajouter une option
                        </button>
                        <small class="text-muted">Maximum 6 options</small>
                    </div>
                </div>

                <div class="mb-3">
                    <label class="form-label">
                        Explication (optionnel)
                        <small class="text-muted">(@(QuizContent.QuizData.Explanation?.Length ?? 0)/300 caractères)</small>
                    </label>
                    <InputTextArea class="form-control"
                                   @bind-Value="QuizContent.QuizData.Explanation"
                                   rows="2"
                                   maxlength="300"
                                   placeholder="Explication affichée après la réponse..." />
                    <ValidationMessage For="@(() => QuizContent.QuizData.Explanation)" />
                </div>

                <!-- Prévisualisation -->
                <div class="mt-4 p-3 bg-light rounded">
                    <h6 class="text-muted mb-3">
                        <i class="bi bi-eye me-1"></i> Aperçu du quiz
                        <span class="difficulty-badge ms-2">
                            <i class="@GetDifficultyIcon(QuizContent.QuizData.Difficulty) me-1"></i>
                            @QuizContent.QuizData.Difficulty
                        </span>
                    </h6>
                    <div class="quiz-preview">
                        @if (!string.IsNullOrEmpty(QuizContent.QuizData.Question))
                        {
                            <div class="fw-bold mb-3">@QuizContent.QuizData.Question</div>
                            @for (int i = 0; i < QuizContent.QuizData.Options.Count; i++)
                            {
                                var index = i;
                                <div class="form-check">
                                    <input class="form-check-input" type="@(QuizContent.QuizData.Type == "multiple-select" ? "checkbox" : "radio")" disabled />
                                    <label class="form-check-label">
                                        @QuizContent.QuizData.Options[index].Text
                                        @if (QuizContent.QuizData.Options[index].IsCorrect)
                                        {
                                            <i class="bi bi-check-circle text-success ms-1"></i>
                                        }
                                    </label>
                                </div>
                            }
                        }
                        else
                        {
                            <em class="text-muted">Saisissez une question pour voir l'aperçu</em>
                        }
                    </div>
                </div>
            </div>
        }
        else
        {
            <!-- Mode affichage (conserver le code existant) -->
            <div class="quiz-display">
                @if (!string.IsNullOrEmpty(QuizContent.QuizData.Question))
                {
                    <!-- Le code d'affichage existant reste identique -->
                    @* Conserver tout le code d'affichage existant *@
                }
                else
                {
                    <div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle me-2"></i>
                        Ce quiz n'a pas encore été configuré.
                    </div>
                }
            </div>
        }

        <div class="block-controls mt-3">
            <button type="submit" class="btn btn-valid m-2" disabled="@(IsEditing && !editContext.IsModified() || isSaving)">
                @if (isSaving)
                {
                    <span class="spinner-border spinner-border-sm me-1"></span>
                    <span>Enregistrement...</span>
                }
                else
                {
                    <i class="bi bi-@(IsEditing ? "floppy" : "pencil")"> </i>
                    @(IsEditing ? " Enregistrer" : "Modifier")
                }
            </button>
            
            @if (!IsEditing)
            {
                <button type="button" class="btn btn-cancel" @onclick="RequestDelete" title="Supprimer ce bloc">
                    <i class="bi bi-trash"></i> Supprimer
                </button>
            }
            else
            {
                <button type="button" class="btn btn-cancel" @onclick="CancelEdit" title="Annuler les modifications">
                    <i class="bi bi-x-lg"></i> Annuler
                </button>
            }
        </div>

        <!-- Indicateurs d'état (similaires à TextBlock) -->
        @if (showSaveSuccess)
        {
            <div class="alert alert-success mt-2 p-2 fade-out">
                <i class="bi bi-check-circle-fill"></i>
                Modifications enregistrées avec succès
            </div>
        }

        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <div class="alert alert-danger mt-2 p-2" role="alert">
                <i class="bi bi-exclamation-triangle-fill"></i>
                @errorMessage
                <button type="button" class="btn-close btn-close-sm ms-2" @onclick="ClearError" aria-label="Fermer"></button>
            </div>
        }
    </div>
</EditForm>

@code {
    [Parameter] public CourBuilder.CoursBlock Block { get; set; } = default!;
    [Parameter(CaptureUnmatchedValues = true)] public Dictionary<string, object>? AdditionalAttributes { get; set; }
    [Parameter] public EventCallback<CourBuilder.CoursBlock> OnBlockChanged { get; set; }
    [Parameter] public EventCallback<CourBuilder.CoursBlock> OnDeleteRequested { get; set; }

    // État du composant
    private bool IsEditing { get; set; } = false;
    private bool isSaving { get; set; } = false;
    private bool showSaveSuccess { get; set; } = false;
    private string? errorMessage;
    private EditContext? editContext;
    private QuizBlockContent? _originalContent;
    private Timer? _successMessageTimer;

    // Contenu typé pour la validation
    private QuizBlockContent QuizContent { get; set; } = new();

    // Propriétés pour l'affichage du quiz (conservées du code original)
    private bool IsAnswered { get; set; } = false;
    private bool? IsCorrect { get; set; } = null;
    private List<bool> UserAnswers { get; set; } = new();
    private string ValidationMessage { get; set; } = string.Empty;
    private bool isSubmitting { get; set; } = false;
    private bool hintShown { get; set; } = false;

    private string showFeedbackId => $"showFeedback-{Block.Order}";

    protected override void OnInitialized()
    {
        LoadQuizData();
        InitializeUserAnswers();
        InitializeEditContext();
    }

    private void InitializeEditContext()
    {
        editContext = new EditContext(QuizContent);
    }

    private async Task RequestDelete()
    {
        await OnDeleteRequested.InvokeAsync(Block);
    }

    private void LoadQuizData()
    {
        try
        {
            if (!string.IsNullOrEmpty(Block.Content?.ToString()))
            {
                var options = new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true,
                    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
                };
                
                var quizData = JsonSerializer.Deserialize<QuizStructure>(Block.Content.ToString(), options) ?? new QuizStructure();
                
                if (quizData.Options == null || !quizData.Options.Any())
                {
                    quizData = CreateDefaultQuizData();
                }
                
                QuizContent = new QuizBlockContent
                {
                    Title = Block.Title,
                    QuizData = quizData
                };

                Console.WriteLine($"Quiz chargé: {quizData.Options.Count} options");
                for (int i = 0; i < quizData.Options.Count; i++)
                {
                    Console.WriteLine($"Option {i}: {quizData.Options[i].Text} - IsCorrect: {quizData.Options[i].IsCorrect}");
                }
            }
            else
            {
                QuizContent = new QuizBlockContent
                {
                    Title = Block.Title,
                    QuizData = CreateDefaultQuizData()
                };
            }
        }
        catch (JsonException ex)
        {
            Console.WriteLine($"Erreur de désérialisation JSON: {ex.Message}");
            QuizContent = new QuizBlockContent
            {
                Title = Block.Title,
                QuizData = CreateDefaultQuizData()
            };
        }
    }

    private void InitializeUserAnswers()
    {
        UserAnswers = new List<bool>();
        if (QuizContent?.QuizData?.Options != null)
        {
            foreach (var _ in QuizContent.QuizData.Options)
            {
                UserAnswers.Add(false);
            }
        }
    }

    private QuizStructure CreateDefaultQuizData()
    {
        var quiz = new QuizStructure();
        quiz.Options.Add(new Option { Text = "", IsCorrect = false });
        quiz.Options.Add(new Option { Text = "", IsCorrect = false });
        return quiz;
    }

    private async Task HandleValidSubmit()
    {
        if (IsEditing)
        {
            await SaveChanges();
        }
        else
        {
            await StartEditing();
        }
    }

    private async Task StartEditing()
    {
        // ⭐ AMÉLIORATION : Clonage profond sécurisé
        _originalContent = CloneQuizContent(QuizContent);
        
        IsEditing = true;
        ClearError();
        StateHasChanged();
    }

    // ⭐ NOUVELLE MÉTHODE : Clonage sécurisé
    private QuizBlockContent CloneQuizContent(QuizBlockContent original)
    {
        var clone = new QuizBlockContent
        {
            Title = original.Title,
            QuizData = new QuizStructure
            {
                Question = original.QuizData.Question,
                Type = original.QuizData.Type,
                Difficulty = original.QuizData.Difficulty,
                ShowProgress = original.QuizData.ShowProgress,
                ShowStats = original.QuizData.ShowStats,
                AllowHint = original.QuizData.AllowHint,
                Hint = original.QuizData.Hint,
                ShowValidationFeedback = original.QuizData.ShowValidationFeedback,
                ShowCorrectAnswer = original.QuizData.ShowCorrectAnswer,
                Explanation = original.QuizData.Explanation,
                Options = original.QuizData.Options.Select(o => new Option 
                { 
                    Text = o.Text, 
                    IsCorrect = o.IsCorrect 
                }).ToList()
            }
        };
        return clone;
    }

    private async Task SaveChanges()
    {
        try
        {
            isSaving = true;
            StateHasChanged();
            ClearError();

            // Validation avant sauvegarde
            if (!ValidateQuizBeforeSave())
            {
                return;
            }

            Console.WriteLine("=== AVANT SAUVEGARDE ===");
            for (int i = 0; i < QuizContent.QuizData.Options.Count; i++)
            {
                Console.WriteLine($"Option {i}: {QuizContent.QuizData.Options[i].Text} - IsCorrect: {QuizContent.QuizData.Options[i].IsCorrect}");
            }

            var options = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
                DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
                WriteIndented = true
            };

            var serializedContent = JsonSerializer.Serialize(QuizContent.QuizData, options);
            
            Console.WriteLine($"=== CONTENU SÉRIALISÉ ===");
            Console.WriteLine(serializedContent);

            Block.Title = QuizContent.Title;
            Block.Content = serializedContent;

            await OnBlockChanged.InvokeAsync(Block);
            
            _originalContent = null;
            IsEditing = false;
            
            InitializeEditContext();
            await ShowSuccessMessage();
        }
        catch (Exception ex)
        {
            errorMessage = $"Erreur lors de la sauvegarde: {ex.Message}";
            Console.WriteLine($"Erreur sauvegarde: {ex.Message}");
        }
        finally
        {
            isSaving = false;
            StateHasChanged();
        }
    }

    // ⭐ NOUVELLE MÉTHODE : Validation avant sauvegarde
    private bool ValidateQuizBeforeSave()
    {
        if (string.IsNullOrWhiteSpace(QuizContent.QuizData.Question))
        {
            errorMessage = "La question est obligatoire";
            return false;
        }

        if (!QuizContent.QuizData.Options.Any(o => o.IsCorrect))
        {
            errorMessage = "Au moins une réponse correcte doit être sélectionnée";
            return false;
        }

        if (QuizContent.QuizData.Options.Any(o => string.IsNullOrWhiteSpace(o.Text)))
        {
            errorMessage = "Toutes les options doivent avoir un texte";
            return false;
        }

        return true;
    }

    private async Task CancelEdit()
    {
        if (_originalContent != null)
        {
            QuizContent = CloneQuizContent(_originalContent);
            Block.Title = _originalContent.Title;
            
            var options = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
                DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
                WriteIndented = true
            };
            
            Block.Content = JsonSerializer.Serialize(_originalContent.QuizData, options);
            _originalContent = null;
        }

        IsEditing = false;
        ClearError();
        InitializeEditContext();
        StateHasChanged();
    }

    private async Task ShowSuccessMessage()
    {
        showSaveSuccess = true;
        StateHasChanged();

        _successMessageTimer?.Dispose();
        _successMessageTimer = new Timer(_ => InvokeAsync(() =>
        {
            showSaveSuccess = false;
            StateHasChanged();
        }), null, TimeSpan.FromSeconds(3), Timeout.InfiniteTimeSpan);
    }

    private void ClearError()
    {
        errorMessage = null;
    }

    // ⭐ CORRECTIONS PRINCIPALES : Nouvelles méthodes pour la gestion des réponses correctes

    // Pour les checkboxes (choix multiple)
    private void OnCorrectAnswerChanged(int index)
    {
        Console.WriteLine($"Checkbox changé - Option {index}: IsCorrect = {QuizContent.QuizData.Options[index].IsCorrect}");
        
        // Notifier les changements de validation
        editContext?.NotifyFieldChanged(new FieldIdentifier(QuizContent.QuizData, nameof(QuizContent.QuizData.OptionsValidation)));
        editContext?.NotifyValidationStateChanged();
        
        StateHasChanged();
    }

    // Pour les boutons radio (choix unique)
    private void HandleRadioClick(int selectedIndex)
    {
        Console.WriteLine($"Radio cliqué - Option {selectedIndex} sélectionnée");
        
        // Décocher toutes les options
        for (int i = 0; i < QuizContent.QuizData.Options.Count; i++)
        {
            QuizContent.QuizData.Options[i].IsCorrect = false;
        }
        
        // Cocher l'option sélectionnée
        QuizContent.QuizData.Options[selectedIndex].IsCorrect = true;
        
        Console.WriteLine("Nouvel état des options:");
        for (int i = 0; i < QuizContent.QuizData.Options.Count; i++)
        {
            Console.WriteLine($"Option {i}: IsCorrect = {QuizContent.QuizData.Options[i].IsCorrect}");
        }
        
        // Notifier les changements
        editContext?.NotifyFieldChanged(new FieldIdentifier(QuizContent.QuizData, nameof(QuizContent.QuizData.OptionsValidation)));
        editContext?.NotifyValidationStateChanged();
        
        StateHasChanged();
    }

    // ⭐ SUPPRIMÉES : Les anciennes méthodes HandleCheckboxChange et HandleRadioChange

    private void AddOption()
    {
        if (QuizContent.QuizData.Options.Count < 6)
        {
            QuizContent.QuizData.Options.Add(new Option { Text = "", IsCorrect = false });
            UserAnswers.Add(false);
            InitializeEditContext();
            StateHasChanged();
        }
    }

    private void RemoveOption(int index)
    {
        if (QuizContent.QuizData.Options.Count > GetMinimumOptions())
        {
            QuizContent.QuizData.Options.RemoveAt(index);
            if (UserAnswers.Count > index)
            {
                UserAnswers.RemoveAt(index);
            }
            InitializeEditContext();
            StateHasChanged();
        }
    }

    private int GetMinimumOptions() => QuizContent.QuizData.Type == "true-false" ? 2 : 2;

    private void OnQuizTypeChanged()
    {
        var newType = QuizContent.QuizData.Type ?? "multiple-choice";

        if (newType == "true-false")
        {
            QuizContent.QuizData.Options.Clear();
            QuizContent.QuizData.Options.Add(new Option { Text = "Vrai", IsCorrect = false });
            QuizContent.QuizData.Options.Add(new Option { Text = "Faux", IsCorrect = false });
        }

        InitializeUserAnswers();
        InitializeEditContext();
        StateHasChanged();
    }

    private string GetTypeClass()
    {
        return QuizContent?.QuizData?.Type switch
        {
            "multiple-choice" => "quiz-mc",
            "multiple-select" => "quiz-ms",
            "true-false" => "quiz-tf",
            _ => "quiz-unknown"
        };
    }

    private string GetDifficultyClass()
    {
        return QuizContent?.QuizData?.GetDifficultyClass() ?? "difficulty-beginner";
    }

    private string GetDifficultyDisplayText(QuizDifficulty difficulty)
    {
        return difficulty switch
        {
            QuizDifficulty.Débutant => "⭐ Débutant",
            QuizDifficulty.Intermédiaire => "⭐⭐ Intermédiaire",
            QuizDifficulty.Avancé => "⭐⭐⭐ Avancé",
            QuizDifficulty.Expert => "⭐⭐⭐⭐ Expert",
            _ => "⭐ Débutant"
        };
    }

    private string GetDifficultyIcon(QuizDifficulty difficulty)
    {
        return difficulty switch
        {
            QuizDifficulty.Débutant => "bi-star",
            QuizDifficulty.Intermédiaire => "bi-star-fill",
            QuizDifficulty.Avancé => "bi-lightning-fill",
            QuizDifficulty.Expert => "bi-trophy-fill",
            _ => "bi-star"
        };
    }

    private string GetDifficultyDescription(QuizDifficulty difficulty)
    {
        return difficulty switch
        {
            QuizDifficulty.Débutant => "Accessible à tous, concepts de base",
            QuizDifficulty.Intermédiaire => "Quelques prérequis nécessaires",
            QuizDifficulty.Avancé => "Connaissances solides requises",
            QuizDifficulty.Expert => "Niveau très élevé, pour les experts",
            _ => "Accessible à tous"
        };
    }

    public void Dispose()
    {
        _successMessageTimer?.Dispose();
    }
}