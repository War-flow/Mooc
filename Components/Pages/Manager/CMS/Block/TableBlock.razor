@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using Mooc.Services
@inject IJSRuntime JSRuntime
@inject BlockService BlockService
@implements IAsyncDisposable

<div class="table-block @GetTypeClass()" @attributes="AdditionalAttributes">
    <h4 class="table-title @(string.IsNullOrEmpty(TypedContent.Title) ? "text-muted" : "")">
        @if (IsEditing)
        {
            <InputText class="form-control" @bind-Value="TypedContent.Title" placeholder="Titre (optionnel)" />
            @if (titleError)
            {
                <small class="text-danger">Le titre ne peut pas dépasser 100 caractères</small>
            }
            <ValidationMessage For="@(() => TypedContent.Title)" />
        }
        else if (!string.IsNullOrEmpty(TypedContent.Title))
        {
            @TypedContent.Title
        }
    </h4>

    <div class="table-content">
        @if (IsEditing)
        {
            <div class="mb-3">
                <div class="table-editor">
                    <div class="table-controls mb-2">
                        <button type="button" class="btn btn-sm btn-outline-secondary me-1" @onclick="AddRow">
                            <i class="bi bi-plus-circle"></i> Ligne
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-secondary me-1" @onclick="AddColumn">
                            <i class="bi bi-plus-circle"></i> Colonne
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-secondary me-1" @onclick="AddHeader"
                                title="Ajouter/Supprimer l'en-tête">
                            <i class="bi bi-list-ol"></i> En-tête
                        </button>
                        <div class="dropdown d-inline-block">
                            <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button"
                                    id="tableStyleDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                Style
                            </button>
                            <ul class="dropdown-menu" aria-labelledby="tableStyleDropdown">
                                <li><button type="button" class="dropdown-item" @onclick='() => ApplyTableStyle("table")'>Standard</button></li>
                                <li><button type="button" class="dropdown-item" @onclick='() => ApplyTableStyle("table table-striped")'>Rayé</button></li>
                                <li><button type="button" class="dropdown-item" @onclick='() => ApplyTableStyle("table table-bordered")'>Bordé</button></li>
                                <li><button type="button" class="dropdown-item" @onclick='() => ApplyTableStyle("table table-hover")'>Survol</button></li>
                                <li><button type="button" class="dropdown-item" @onclick='() => ApplyTableStyle("table table-sm")'>Compact</button></li>
                            </ul>
                        </div>
                    </div>

                    <div class="table-responsive">
                        <table class="@TypedContent.TableStyle">
                            @if (TypedContent.HasHeader)
                            {
                                <thead>
                                    <tr>
                                        @for (int i = 0; i < TypedContent.TableColumns; i++)
                                        {
                                            int colIndex = i;
                                            <th>
                                                <div class="d-flex align-items-center">
                                                    <input type="text" class="form-control form-control-sm"
                                                           @bind="TypedContent.HeaderCells[colIndex]" @oninput="OnTableContentChanged" />
                                                    <button type="button" class="btn btn-sm btn-outline-danger ms-1"
                                                            @onclick="() => RemoveColumn(colIndex)" title="Supprimer colonne">
                                                        <i class="bi bi-trash"></i>
                                                    </button>
                                                </div>
                                            </th>
                                        }
                                    </tr>
                                </thead>
                            }
                            <tbody>
                                @for (int r = 0; r < TypedContent.TableRows; r++)
                                {
                                    int rowIndex = r;
                                    <tr>
                                        @for (int c = 0; c < TypedContent.TableColumns; c++)
                                        {
                                            int colIndex = c;
                                            <td>
                                                <div class="d-flex align-items-center">
                                                    <input type="text" class="form-control form-control-sm"
                                                           @bind="TypedContent.TableCells[rowIndex][colIndex]" @oninput="OnTableContentChanged" />
                                                    @if (c == 0)
                                                    {
                                                        <button type="button" class="btn btn-sm btn-outline-danger ms-1"
                                                                @onclick="() => RemoveRow(rowIndex)" title="Supprimer ligne">
                                                            <i class="bi bi-trash"></i>
                                                        </button>
                                                    }
                                                </div>
                                            </td>
                                        }
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        }
        else
        {
            <!-- Aperçu du tableau -->
            <div class="table-display table-responsive">
                @if (!string.IsNullOrEmpty(TypedContent.TableContent))
                {
                    @((MarkupString)TypedContent.TableContent)
                }
                else
                {
                    <div class="text-muted">Tableau vide</div>
                }
            </div>
        }
    </div>

    <div class="block-controls mt-2">
        <button type="button" class="btn-block btn-valid"
                @onclick="ToggleEdit" disabled="@(IsEditing && !IsValid())"
                aria-label="@(IsEditing ? "Enregistrer les modifications" : "Modifier le bloc")">
            <i class="bi bi-@(IsEditing ? "floppy" : "pencil")"></i>
            @(IsEditing ? "Enregistrer" : "Modifier")
        </button>
        
        @if (IsEditing)
        {
            <button type="button" class="btn-block btn-cancel" @onclick="CancelEdit"
                    aria-label="Annuler les modifications">
                <i class="bi bi-x-lg"></i> Annuler
            </button>
        }
        else
        {
            <button type="button" class="btn-block btn-cancel" @onclick="RequestDelete"
                    title="Supprimer ce bloc">
                <i class="bi bi-trash"> Supprimer</i>
            </button>
        }
    </div>

    <!-- Indicateur de sauvegarde -->
    @if (isSaving)
    {
        <div class="save-indicator">
            <span class="spinner-border spinner-border-sm text-primary" role="status"></span>
            <span class="ms-1">Sauvegarde en cours...</span>
        </div>
    }

    <!-- Message de succès temporaire -->
    @if (showSaveSuccess)
    {
        <div class="alert alert-success mt-2 p-2 fade-out">
            Modifications enregistrées avec succès
        </div>
    }

    <!-- Message d'erreur -->
    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger mt-2 p-2">
            @errorMessage
        </div>
    }
</div>

@code {
    [Parameter]
    public CourBuilder.CoursBlock Block { get; set; } = default!;

    [Parameter]
    public int CoursId { get; set; }

    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnBlockChanged { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnDeleteRequested { get; set; }

    [CascadingParameter]
    private EditContext? EditContext { get; set; }

    private bool IsEditing { get; set; } = false;
    private bool titleError { get; set; } = false;
    private bool isSaving { get; set; } = false;
    private bool showSaveSuccess { get; set; } = false;
    private string? errorMessage;
    private TableBlockContent? _originalContent;

    // Propriété de commodité pour accéder au contenu typé
    private TableBlockContent TypedContent => Block.Content as TableBlockContent ?? new TableBlockContent();

    protected override void OnInitialized()
    {
        EnsureContentInitialized();
    }

    protected override void OnParametersSet()
    {
        EnsureContentInitialized();
    }

    private void EnsureContentInitialized()
    {
        if (Block.Content is not TableBlockContent)
        {
            Block.Content = new TableBlockContent
            {
                Title = Block.Title ?? string.Empty,
                TableRows = 2,
                TableColumns = 2,
                HasHeader = true,
                TableStyle = "table table-bordered",
                HeaderCells = new List<string> { "Colonne 1", "Colonne 2" },
                TableCells = new List<List<string>> {
                    new List<string> { "Cellule 1,1", "Cellule 1,2" },
                    new List<string> { "Cellule 2,1", "Cellule 2,2" }
                }
            };
            
            GenerateTableFromVisual();
        }
        else if (!string.IsNullOrEmpty(TypedContent.TableContent))
        {
            // Essayer de parser le HTML du tableau existant si nécessaire
            ParseExistingTable();
        }
    }

    private bool IsValid()
    {
        return TypedContent.TableRows > 0 && TypedContent.TableColumns > 0;
    }

    private bool ValidateBlock()
    {
        errorMessage = null;
        titleError = false;

        if (TypedContent.Title.Length > 100)
        {
            titleError = true;
            errorMessage = "Le titre ne peut pas dépasser 100 caractères";
            return false;
        }

        if (TypedContent.TableRows <= 0 || TypedContent.TableColumns <= 0)
        {
            errorMessage = "Le tableau doit contenir au moins une ligne et une colonne";
            return false;
        }

        return true;
    }

    private async Task ToggleEdit()
    {
        if (IsEditing)
        {
            if (!IsValid() || !ValidateBlock())
                return;

            try
            {
                isSaving = true;
                StateHasChanged();

                // Générer le HTML depuis le mode visuel
                GenerateTableFromVisual();

                // Synchroniser vers Block pour compatibilité
                Block.Title = TypedContent.Title;
                Block.Content = TypedContent;
                
                _originalContent = null;
                IsEditing = false;
                
                // Sauvegarder en base de données si nécessaire
                if (CoursId > 0)
                {
                    bool success = await BlockService.SaveBlockAsync(Block, CoursId);
                    if (!success)
                    {
                        errorMessage = "Erreur lors de la sauvegarde en base de données";
                        return;
                    }
                }
                
                await OnBlockChanged.InvokeAsync(Block);
                
                showSaveSuccess = true;
                StateHasChanged();
                
                await Task.Delay(2000);
                showSaveSuccess = false;
            }
            catch (Exception ex)
            {
                errorMessage = "Erreur lors de la sauvegarde. Veuillez réessayer.";
                Console.WriteLine($"Erreur lors de la sauvegarde: {ex.Message}");
            }
            finally
            {
                isSaving = false;
                StateHasChanged();
            }
        }
        else
        {
            // Créer un backup
            _originalContent = new TableBlockContent
            {
                Title = TypedContent.Title,
                TableRows = TypedContent.TableRows,
                TableColumns = TypedContent.TableColumns,
                HasHeader = TypedContent.HasHeader,
                TableStyle = TypedContent.TableStyle,
                HeaderCells = new List<string>(TypedContent.HeaderCells),
                TableCells = TypedContent.TableCells.Select(row => new List<string>(row)).ToList(),
                TableContent = TypedContent.TableContent
            };
            
            IsEditing = true;
        }
    }

    private void CancelEdit()
    {
        if (_originalContent != null)
        {
            Block.Content = _originalContent;
            Block.Title = _originalContent.Title;
        }
        
        IsEditing = false;
        errorMessage = null;
        titleError = false;
    }

    private void OnTableContentChanged()
    {
        // Régénérer le HTML à chaque changement
        GenerateTableFromVisual();
    }

    private void AddRow()
    {
        List<string> newRow = new List<string>();
        for (int i = 0; i < TypedContent.TableColumns; i++)
        {
            newRow.Add($"Cellule {TypedContent.TableRows + 1},{i + 1}");
        }
        TypedContent.TableCells.Add(newRow);
        TypedContent.TableRows++;
        
        GenerateTableFromVisual();
    }

    private void RemoveRow(int rowIndex)
    {
        if (TypedContent.TableRows > 1)
        {
            TypedContent.TableCells.RemoveAt(rowIndex);
            TypedContent.TableRows--;
            
            GenerateTableFromVisual();
        }
    }

    private void AddColumn()
    {
        // Ajouter une cellule à chaque ligne
        for (int i = 0; i < TypedContent.TableRows; i++)
        {
            TypedContent.TableCells[i].Add($"Cellule {i + 1},{TypedContent.TableColumns + 1}");
        }

        // Ajouter une cellule d'en-tête
        TypedContent.HeaderCells.Add($"Colonne {TypedContent.TableColumns + 1}");
        TypedContent.TableColumns++;
        
        GenerateTableFromVisual();
    }

    private void RemoveColumn(int colIndex)
    {
        if (TypedContent.TableColumns > 1)
        {
            // Supprimer la cellule de chaque ligne
            for (int i = 0; i < TypedContent.TableRows; i++)
            {
                TypedContent.TableCells[i].RemoveAt(colIndex);
            }

            // Supprimer la cellule d'en-tête
            TypedContent.HeaderCells.RemoveAt(colIndex);
            TypedContent.TableColumns--;
            
            GenerateTableFromVisual();
        }
    }

    private void AddHeader()
    {
        TypedContent.HasHeader = !TypedContent.HasHeader;
        GenerateTableFromVisual();
    }

    private void ApplyTableStyle(string style)
    {
        TypedContent.TableStyle = style;
        GenerateTableFromVisual();
    }

    private void GenerateTableFromVisual()
    {
        var tableHtml = new System.Text.StringBuilder();
        tableHtml.AppendLine("<div class=\"table-responsive\">");
        tableHtml.AppendLine($"<table class=\"{TypedContent.TableStyle}\">");

        // Ajouter l'en-tête si nécessaire
        if (TypedContent.HasHeader)
        {
            tableHtml.AppendLine("<thead>");
            tableHtml.AppendLine("<tr>");
            foreach (var header in TypedContent.HeaderCells)
            {
                tableHtml.AppendLine($"<th>{header}</th>");
            }
            tableHtml.AppendLine("</tr>");
            tableHtml.AppendLine("</thead>");
        }

        // Ajouter le corps du tableau
        tableHtml.AppendLine("<tbody>");
        for (int r = 0; r < TypedContent.TableRows; r++)
        {
            tableHtml.AppendLine("<tr>");
            for (int c = 0; c < TypedContent.TableColumns; c++)
            {
                tableHtml.AppendLine($"<td>{TypedContent.TableCells[r][c]}</td>");
            }
            tableHtml.AppendLine("</tr>");
        }
        tableHtml.AppendLine("</tbody>");
        tableHtml.AppendLine("</table>");
        tableHtml.AppendLine("</div>");

        TypedContent.TableContent = tableHtml.ToString();
    }

    // Parse le contenu HTML existant pour le mode visuel
    private void ParseExistingTable()
    {
        try
        {
            // Cette fonction est simplifiée et pourrait être améliorée avec une vraie analyse HTML
            var content = TypedContent.TableContent.ToLower();

            // Vérifie si le tableau a un en-tête
            TypedContent.HasHeader = content.Contains("<thead>");

            // Extraire le style du tableau
            if (content.Contains("table-striped"))
                TypedContent.TableStyle = "table table-striped";
            else if (content.Contains("table-bordered"))
                TypedContent.TableStyle = "table table-bordered";
            else if (content.Contains("table-hover"))
                TypedContent.TableStyle = "table table-hover";
            else if (content.Contains("table-sm"))
                TypedContent.TableStyle = "table table-sm";
            else
                TypedContent.TableStyle = "table";
        }
        catch
        {
            // En cas d'erreur d'analyse, utiliser la structure par défaut
            ResetTableStructure();
        }
    }

    private void ResetTableStructure()
    {
        TypedContent.TableRows = 2;
        TypedContent.TableColumns = 2;
        TypedContent.HasHeader = true;
        TypedContent.TableStyle = "table table-bordered";
        TypedContent.HeaderCells = new List<string> { "Colonne 1", "Colonne 2" };
        TypedContent.TableCells = new List<List<string>> {
            new List<string> { "Cellule 1,1", "Cellule 1,2" },
            new List<string> { "Cellule 2,1", "Cellule 2,2" }
        };
    }

    private string GetTypeClass()
    {
        var classList = new List<string>();

        if (IsEditing)
        {
            classList.Add("editing");
        }

        if (string.IsNullOrEmpty(TypedContent.TableContent))
        {
            classList.Add("empty");
        }

        return string.Join(" ", classList);
    }

    private async Task RequestDelete()
    {
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Êtes-vous sûr de vouloir supprimer ce bloc tableau ?");
        if (confirmed)
        {
            if (CoursId > 0)
            {
                // Supprimer de la base de données
                bool success = await BlockService.DeleteBlockAsync(Block.Id, CoursId);
                if (success && OnDeleteRequested.HasDelegate)
                {
                    await OnDeleteRequested.InvokeAsync(Block);
                }
            }
            else if (OnDeleteRequested.HasDelegate)
            {
                await OnDeleteRequested.InvokeAsync(Block);
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        _originalContent = null;
        await Task.CompletedTask;
    }

    // Classe pour contenu spécifique à TableBlock
    public class TableBlockContent
    {
        public string Title { get; set; } = string.Empty;
        public int TableRows { get; set; } = 2;
        public int TableColumns { get; set; } = 2;
        public bool HasHeader { get; set; } = true;
        public string TableStyle { get; set; } = "table table-bordered";
        public List<string> HeaderCells { get; set; } = new();
        public List<List<string>> TableCells { get; set; } = new();
        public string TableContent { get; set; } = string.Empty;
    }
}