@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using Mooc.Services
@using System.Text.RegularExpressions
@using System.Text.Encodings.Web
@using System.Text.Json
@using Microsoft.EntityFrameworkCore
@using Mooc.Data
@inject IJSRuntime JSRuntime
@inject BlockService BlockService
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@implements IAsyncDisposable

<div class="table-block @GetTypeClass()" @attributes="AdditionalAttributes">
    <h4 class="table-title @(string.IsNullOrEmpty(TypedContent.Title) ? "text-muted" : "")">
        @if (IsEditing)
        {
            <InputText class="form-control" @bind-Value="TypedContent.Title" placeholder="Titre (optionnel)" />
            @if (titleError)
            {
                <small class="text-danger">Le titre ne peut pas dépasser 100 caractères</small>
            }
            <ValidationMessage For="@(() => TypedContent.Title)" />
        }
        else if (!string.IsNullOrEmpty(TypedContent.Title))
        {
            @TypedContent.Title
        }
    </h4>

    <div class="table-content">
        @if (IsEditing)
        {
            <div class="mb-3">
                <div class="table-editor">
                    <div class="table-controls mb-2">
                        <button type="button" class="btn btn-sm btn-outline-secondary me-1" @onclick="AddRow">
                            <i class="bi bi-plus-circle"></i> Ligne
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-secondary me-1" @onclick="AddColumn">
                            <i class="bi bi-plus-circle"></i> Colonne
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-secondary me-1" @onclick="AddHeader"
                                title="Ajouter/Supprimer l'en-tête">
                            <i class="bi bi-list-ol"></i> En-tête
                        </button>
                        <div class="dropdown d-inline-block">
                            <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button"
                                    id="tableStyleDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                Style
                            </button>
                            <ul class="dropdown-menu" aria-labelledby="tableStyleDropdown">
                                <li><button type="button" class="dropdown-item" @onclick='() => ApplyTableStyle("table")'>Standard</button></li>
                                <li><button type="button" class="dropdown-item" @onclick='() => ApplyTableStyle("table table-striped")'>Rayé</button></li>
                                <li><button type="button" class="dropdown-item" @onclick='() => ApplyTableStyle("table table-bordered")'>Bordé</button></li>
                                <li><button type="button" class="dropdown-item" @onclick='() => ApplyTableStyle("table table-hover")'>Survol</button></li>
                                <li><button type="button" class="dropdown-item" @onclick='() => ApplyTableStyle("table table-sm")'>Compact</button></li>
                            </ul>
                        </div>
                    </div>

                    <div class="table-responsive">
                        <table class="@TypedContent.TableStyle">
                            @if (TypedContent.HasHeader && TypedContent.HeaderCells.Count > 0)
                            {
                                <thead>
                                    <tr>
                                        @for (int i = 0; i < TypedContent.TableColumns && i < TypedContent.HeaderCells.Count; i++)
                                        {
                                            int colIndex = i;
                                            <th>
                                                <div class="d-flex align-items-center">
                                                    <input type="text" class="form-control form-control-sm"
                                                           @bind="TypedContent.HeaderCells[colIndex]" @oninput="OnTableContentChanged" />
                                                    <button type="button" class="btn btn-sm btn-outline-danger ms-1"
                                                            @onclick="() => RemoveColumn(colIndex)" title="Supprimer colonne">
                                                        <i class="bi bi-trash"></i>
                                                    </button>
                                                </div>
                                            </th>
                                        }
                                    </tr>
                                </thead>
                            }
                            <tbody>
                                @for (int r = 0; r < TypedContent.TableRows && r < TypedContent.TableCells.Count; r++)
                                {
                                    int rowIndex = r;
                                    <tr>
                                        @for (int c = 0; c < TypedContent.TableColumns && c < TypedContent.TableCells[r].Count; c++)
                                        {
                                            int colIndex = c;
                                            <td>
                                                <div class="d-flex align-items-center">
                                                    <input type="text" class="form-control form-control-sm"
                                                           @bind="TypedContent.TableCells[rowIndex][colIndex]" @oninput="OnTableContentChanged" />
                                                    @if (c == 0)
                                                    {
                                                        <button type="button" class="btn btn-sm btn-outline-danger ms-1"
                                                                @onclick="() => RemoveRow(rowIndex)" title="Supprimer ligne">
                                                            <i class="bi bi-trash"></i>
                                                        </button>
                                                    }
                                                </div>
                                            </td>
                                        }
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        }
        else
        {
            <!-- Aperçu du tableau -->
            <div class="table-display table-responsive">
                @if (!string.IsNullOrEmpty(TypedContent.TableContent))
                {
                    @((MarkupString)TypedContent.TableContent)
                }
                else
                {
                    <div class="text-muted">Tableau vide</div>
                }
            </div>
        }
    </div>

    <div class="block-controls mt-2">
        <button type="button" class="btn-block btn-valid"
                @onclick="ToggleEdit" disabled="@(IsEditing && !IsValid())"
                aria-label="@(IsEditing ? "Enregistrer les modifications" : "Modifier le bloc")">
            <i class="bi bi-@(IsEditing ? "floppy" : "pencil")"></i>
            @(IsEditing ? "Enregistrer" : "Modifier")
        </button>
        
        @if (IsEditing)
        {
            <button type="button" class="btn-block btn-cancel" @onclick="CancelEdit"
                    aria-label="Annuler les modifications">
                <i class="bi bi-x-lg"></i> Annuler
            </button>
        }
        else
        {
            <button type="button" class="btn-block btn-cancel" @onclick="RequestDelete"
                    title="Supprimer ce bloc">
                <i class="bi bi-trash"> Supprimer</i>
            </button>
        }
    </div>

    <!-- Indicateur de sauvegarde -->
    @if (isSaving)
    {
        <div class="save-indicator">
            <span class="spinner-border spinner-border-sm text-primary" role="status"></span>
            <span class="ms-1">Sauvegarde en cours...</span>
        </div>
    }

    <!-- Message de succès temporaire -->
    @if (showSaveSuccess)
    {
        <div class="alert alert-success mt-2 p-2 fade-out">
            Modifications enregistrées avec succès
        </div>
    }

    <!-- Message d'erreur -->
    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger mt-2 p-2">
            @errorMessage
        </div>
    }
</div>

@code {
    [Parameter]
    public CourBuilder.CoursBlock Block { get; set; } = default!;

    [Parameter]
    public int CoursId { get; set; }

    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnBlockChanged { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnDeleteRequested { get; set; }

    [CascadingParameter]
    private EditContext? EditContext { get; set; }

    private bool IsEditing { get; set; } = false;
    private bool titleError { get; set; } = false;
    private bool isSaving { get; set; } = false;
    private bool showSaveSuccess { get; set; } = false;
    private string? errorMessage;
    private TableBlockContent? _originalContent;
    private bool _isInitialized = false;

    // Propriété de commodité pour accéder au contenu typé
    private TableBlockContent TypedContent => Block.Content as TableBlockContent ?? new TableBlockContent();

    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine($"TableBlock OnInitializedAsync - CoursId: {CoursId}, Block.Id: {Block.Id}");
        await EnsureContentInitializedAsync();
        _isInitialized = true;
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_isInitialized)
        {
            Console.WriteLine($"TableBlock OnParametersSetAsync - CoursId: {CoursId}, Block.Id: {Block.Id}");
            await EnsureContentInitializedAsync();
        }
    }

    // Méthode asynchrone pour initialiser le contenu
    private async Task EnsureContentInitializedAsync()
    {
        if (Block.Content is not TableBlockContent)
        {
            Console.WriteLine("Initialisation d'un nouveau tableau");
            
            // Vérifier si le bloc existe déjà en base de données
            if (CoursId > 0)
            {
                var existingContent = await LoadBlockContentFromDatabase();
                if (existingContent != null)
                {
                    Console.WriteLine("Contenu trouvé en base de données");
                    Block.Content = existingContent;
                    StateHasChanged();
                    return;
                }
            }
            
            // Créer un nouveau contenu par défaut
            Block.Content = CreateDefaultTableContent();
            GenerateTableFromVisual();
        }
        else
        {
            var content = Block.Content as TableBlockContent;
            if (content != null)
            {
                // Vérifier si le contenu HTML existe mais les structures de données sont vides
                if (!string.IsNullOrEmpty(content.TableContent) && 
                    (content.TableCells == null || content.TableCells.Count == 0))
                {
                    Console.WriteLine("Parse du HTML existant");
                    ParseExistingTable();
                }
                else if (string.IsNullOrEmpty(content.TableContent) && 
                         (content.TableCells == null || content.TableCells.Count == 0))
                {
                    Console.WriteLine("Réinitialisation du tableau");
                    ResetTableStructure();
                    GenerateTableFromVisual();
                }
                else
                {
                    // Vérifier la cohérence des données
                    ValidateAndFixTableStructure();
                }
            }
        }
    }

    // Méthode pour charger le contenu du bloc depuis la base de données
    private async Task<TableBlockContent?> LoadBlockContentFromDatabase()
    {
        if (CoursId <= 0) return null;

        try
        {
            using var context = await DbContextFactory.CreateDbContextAsync();
            var cours = await context.Courses.FindAsync(CoursId);
            
            if (cours != null && !string.IsNullOrEmpty(cours.Content))
            {
                Console.WriteLine($"Contenu trouvé en base: {cours.Content.Substring(0, Math.Min(100, cours.Content.Length))}...");
                
                var blocks = JsonSerializer.Deserialize<List<CourBuilder.CoursBlock>>(cours.Content) ?? new List<CourBuilder.CoursBlock>();
                var matchingBlock = blocks.FirstOrDefault(b => b.Id == Block.Id);
                
                if (matchingBlock?.Content != null)
                {
                    // Convertir le contenu JSON en TableBlockContent
                    var jsonElement = (JsonElement)matchingBlock.Content;
                    var tableContent = JsonSerializer.Deserialize<TableBlockContent>(jsonElement.GetRawText());
                    
                    Console.WriteLine($"Bloc tableau trouvé - Lignes: {tableContent?.TableRows}, Colonnes: {tableContent?.TableColumns}");
                    return tableContent;
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du chargement depuis la base: {ex.Message}");
        }
        
        return null;
    }

    // Méthode pour vérifier la sauvegarde (améliorée)
    private async Task VerifyDatabaseSave()
    {
        try
        {
            using var context = await DbContextFactory.CreateDbContextAsync();
            var cours = await context.Courses.FindAsync(CoursId);
            
            if (cours != null && !string.IsNullOrEmpty(cours.Content))
            {
                var blocksFromDb = JsonSerializer.Deserialize<List<CourBuilder.CoursBlock>>(cours.Content) ?? new List<CourBuilder.CoursBlock>();
                var savedBlock = blocksFromDb.FirstOrDefault(b => b.Id == Block.Id);
                
                if (savedBlock != null)
                {
                    Console.WriteLine($"🔍 VÉRIFICATION: Bloc trouvé en base de données");
                    Console.WriteLine($"Titre sauvegardé: {savedBlock.Title}");
                    Console.WriteLine($"Type: {savedBlock.Type}");
                    Console.WriteLine($"Contenu: {JsonSerializer.Serialize(savedBlock.Content, new JsonSerializerOptions { WriteIndented = true })}");
                }
                else
                {
                    Console.WriteLine($"⚠️ ATTENTION: Bloc non trouvé en base de données");
                }
            }
            else
            {
                Console.WriteLine($"⚠️ ATTENTION: Cours non trouvé ou contenu vide");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ ERREUR lors de la vérification: {ex.Message}");
        }
    }

    // Modifier la méthode ToggleEdit pour inclure la vérification
    private async Task ToggleEdit()
    {
        if (IsEditing)
        {
            if (!IsValid() || !ValidateBlock())
                return;

            try
            {
                isSaving = true;
                errorMessage = null;
                StateHasChanged();

                // Générer le HTML depuis le mode visuel
                GenerateTableFromVisual();

                // Synchroniser vers Block pour compatibilité
                Block.Title = TypedContent.Title;
                Block.Content = TypedContent;
                
                // Sauvegarder en base de données si nécessaire
                if (CoursId > 0)
                {
                    Console.WriteLine($"=== DÉBUT SAUVEGARDE ===");
                    Console.WriteLine($"Bloc ID: {Block.Id}");
                    Console.WriteLine($"Cours ID: {CoursId}");
                    Console.WriteLine($"Titre: {TypedContent.Title}");
                    Console.WriteLine($"Lignes: {TypedContent.TableRows}, Colonnes: {TypedContent.TableColumns}");
                    Console.WriteLine($"Contenu JSON: {JsonSerializer.Serialize(Block.Content, new JsonSerializerOptions { WriteIndented = true })}");
                    
                    bool success = await BlockService.SaveBlockAsync(Block, CoursId);
                    
                    if (!success)
                    {
                        errorMessage = "Erreur lors de la sauvegarde en base de données";
                        Console.WriteLine("❌ ÉCHEC de la sauvegarde du bloc");
                        return;
                    }
                    
                    Console.WriteLine("✅ Bloc sauvegardé avec succès en base de données");
                    
                    // Vérifier immédiatement en rechargeant depuis la base
                    await VerifyDatabaseSave();
                    Console.WriteLine($"=== FIN SAUVEGARDE ===");
                }
                
                _originalContent = null;
                IsEditing = false;
                
                await OnBlockChanged.InvokeAsync(Block);
                
                showSaveSuccess = true;
                StateHasChanged();
                
                // Masquer le message de succès après 2 secondes
                await Task.Delay(2000);
                showSaveSuccess = false;
                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Erreur lors de la sauvegarde: {ex.Message}";
                Console.WriteLine($"❌ ERREUR lors de la sauvegarde: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
            }
            finally
            {
                isSaving = false;
                StateHasChanged();
            }
        }
        else
        {
            // Créer un backup
            _originalContent = new TableBlockContent
            {
                Title = TypedContent.Title,
                TableRows = TypedContent.TableRows,
                TableColumns = TypedContent.TableColumns,
                HasHeader = TypedContent.HasHeader,
                TableStyle = TypedContent.TableStyle,
                HeaderCells = new List<string>(TypedContent.HeaderCells ?? new List<string>()),
                TableCells = TypedContent.TableCells?.Select(row => new List<string>(row ?? new List<string>())).ToList() ?? new List<List<string>>(),
                TableContent = TypedContent.TableContent
            };
            
            IsEditing = true;
        }
    }

    private void CancelEdit()
    {
        if (_originalContent != null)
        {
            Block.Content = _originalContent;
            Block.Title = _originalContent.Title;
        }
        
        IsEditing = false;
        errorMessage = null;
        titleError = false;
    }

    private void OnTableContentChanged()
    {
        // Régénérer le HTML à chaque changement
        GenerateTableFromVisual();
    }

    private void AddRow()
    {
        List<string> newRow = new List<string>();
        for (int i = 0; i < TypedContent.TableColumns; i++)
        {
            newRow.Add($"Cellule {TypedContent.TableRows + 1},{i + 1}");
        }
        TypedContent.TableCells.Add(newRow);
        TypedContent.TableRows++;
        
        GenerateTableFromVisual();
    }

    private void RemoveRow(int rowIndex)
    {
        if (TypedContent.TableRows > 1 && rowIndex < TypedContent.TableCells.Count)
        {
            TypedContent.TableCells.RemoveAt(rowIndex);
            TypedContent.TableRows--;
            
            GenerateTableFromVisual();
        }
    }

    private void AddColumn()
    {
        // Ajouter une cellule à chaque ligne
        for (int i = 0; i < TypedContent.TableRows && i < TypedContent.TableCells.Count; i++)
        {
            TypedContent.TableCells[i].Add($"Cellule {i + 1},{TypedContent.TableColumns + 1}");
        }

        // Ajouter une cellule d'en-tête
        TypedContent.HeaderCells.Add($"Colonne {TypedContent.TableColumns + 1}");
        TypedContent.TableColumns++;
        
        GenerateTableFromVisual();
    }

    private void RemoveColumn(int colIndex)
    {
        if (TypedContent.TableColumns > 1 && colIndex < TypedContent.TableColumns)
        {
            // Supprimer la cellule de chaque ligne
            for (int i = 0; i < TypedContent.TableRows && i < TypedContent.TableCells.Count; i++)
            {
                if (colIndex < TypedContent.TableCells[i].Count)
                {
                    TypedContent.TableCells[i].RemoveAt(colIndex);
                }
            }

            // Supprimer la cellule d'en-tête
            if (colIndex < TypedContent.HeaderCells.Count)
            {
                TypedContent.HeaderCells.RemoveAt(colIndex);
            }
            TypedContent.TableColumns--;
            
            GenerateTableFromVisual();
        }
    }

    private void AddHeader()
    {
        TypedContent.HasHeader = !TypedContent.HasHeader;
        
        // Si on active l'en-tête et qu'il n'y a pas assez de cellules d'en-tête
        if (TypedContent.HasHeader)
        {
            while (TypedContent.HeaderCells.Count < TypedContent.TableColumns)
            {
                TypedContent.HeaderCells.Add($"Colonne {TypedContent.HeaderCells.Count + 1}");
            }
        }
        
        GenerateTableFromVisual();
    }

    private void ApplyTableStyle(string style)
    {
        TypedContent.TableStyle = style;
        GenerateTableFromVisual();
    }

    private void GenerateTableFromVisual()
    {
        var tableHtml = new System.Text.StringBuilder();
        tableHtml.AppendLine("<div class=\"table-responsive\">");
        tableHtml.AppendLine($"<table class=\"{TypedContent.TableStyle}\">");

        // Ajouter l'en-tête si nécessaire
        if (TypedContent.HasHeader && TypedContent.HeaderCells?.Count > 0)
        {
            tableHtml.AppendLine("<thead>");
            tableHtml.AppendLine("<tr>");
            for (int i = 0; i < TypedContent.TableColumns && i < TypedContent.HeaderCells.Count; i++)
            {
                var header = TypedContent.HeaderCells[i] ?? string.Empty;
                tableHtml.AppendLine($"<th>{HtmlEncoder.Default.Encode(header)}</th>");
            }
            tableHtml.AppendLine("</tr>");
            tableHtml.AppendLine("</thead>");
        }

        // Ajouter le corps du tableau
        tableHtml.AppendLine("<tbody>");
        for (int r = 0; r < TypedContent.TableRows && r < TypedContent.TableCells.Count; r++)
        {
            tableHtml.AppendLine("<tr>");
            for (int c = 0; c < TypedContent.TableColumns && c < TypedContent.TableCells[r].Count; c++)
            {
                var cellValue = TypedContent.TableCells[r][c] ?? string.Empty;
                tableHtml.AppendLine($"<td>{HtmlEncoder.Default.Encode(cellValue)}</td>");
            }
            tableHtml.AppendLine("</tr>");
        }
        tableHtml.AppendLine("</tbody>");
        tableHtml.AppendLine("</table>");
        tableHtml.AppendLine("</div>");

        TypedContent.TableContent = tableHtml.ToString();
    }

    // Méthode complètement refactorisée pour le parsing HTML
    private void ParseExistingTable()
    {
        try
        {
            Console.WriteLine($"Parsing HTML: {TypedContent.TableContent?.Substring(0, Math.Min(200, TypedContent.TableContent?.Length ?? 0))}...");
            
            if (string.IsNullOrEmpty(TypedContent.TableContent))
            {
                ResetTableStructure();
                return;
            }

            var content = TypedContent.TableContent;
            
            // Nettoyer le contenu HTML des retours à la ligne et espaces supplémentaires
            content = Regex.Replace(content, @"\s+", " ");
            content = content.Replace("\n", "").Replace("\r", "");

            // Vérifier si le tableau a un en-tête
            TypedContent.HasHeader = content.Contains("<thead>");

            // Extraire le style du tableau
            var tableMatch = Regex.Match(content, @"<table[^>]*class=""([^""]*)"">", RegexOptions.IgnoreCase);
            if (tableMatch.Success)
            {
                TypedContent.TableStyle = tableMatch.Groups[1].Value;
            }
            else
            {
                TypedContent.TableStyle = "table table-bordered";
            }

            // Initialiser les listes
            TypedContent.HeaderCells = new List<string>();
            TypedContent.TableCells = new List<List<string>>();

            // Parser les en-têtes si présents
            if (TypedContent.HasHeader)
            {
                var theadMatch = Regex.Match(content, @"<thead[^>]*>(.*?)</thead>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
                if (theadMatch.Success)
                {
                    var headerMatches = Regex.Matches(theadMatch.Groups[1].Value, @"<th[^>]*>(.*?)</th>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
                    foreach (Match match in headerMatches)
                    {
                        var headerText = System.Net.WebUtility.HtmlDecode(match.Groups[1].Value.Trim());
                        TypedContent.HeaderCells.Add(headerText);
                    }
                }
            }

            // Parser le corps du tableau
            var tbodyMatch = Regex.Match(content, @"<tbody[^>]*>(.*?)</tbody>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
            string bodyContent = tbodyMatch.Success ? tbodyMatch.Groups[1].Value : content;

            // Parser les lignes
            var rowMatches = Regex.Matches(bodyContent, @"<tr[^>]*>(.*?)</tr>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
            foreach (Match rowMatch in rowMatches)
            {
                var row = new List<string>();
                var cellMatches = Regex.Matches(rowMatch.Groups[1].Value, @"<td[^>]*>(.*?)</td>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
                
                foreach (Match cellMatch in cellMatches)
                {
                    var cellText = System.Net.WebUtility.HtmlDecode(cellMatch.Groups[1].Value.Trim());
                    row.Add(cellText);
                }
                
                if (row.Count > 0)
                {
                    TypedContent.TableCells.Add(row);
                }
            }

            // Déterminer les dimensions
            TypedContent.TableRows = TypedContent.TableCells.Count;
            if (TypedContent.TableCells.Count > 0)
            {
                TypedContent.TableColumns = TypedContent.TableCells.Max(row => row.Count);
            }
            else if (TypedContent.HeaderCells.Count > 0)
            {
                TypedContent.TableColumns = TypedContent.HeaderCells.Count;
            }
            else
            {
                TypedContent.TableColumns = 2;
            }

            // Si pas d'en-tête mais on a des colonnes, créer des en-têtes par défaut
            if (!TypedContent.HasHeader || TypedContent.HeaderCells.Count == 0)
            {
                TypedContent.HeaderCells.Clear();
                for (int i = 0; i < TypedContent.TableColumns; i++)
                {
                    TypedContent.HeaderCells.Add($"Colonne {i + 1}");
                }
            }

            // Valider et corriger la structure
            ValidateAndFixTableStructure();

            Console.WriteLine($"Parsing terminé - Lignes: {TypedContent.TableRows}, Colonnes: {TypedContent.TableColumns}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du parsing du tableau: {ex.Message}");
            ResetTableStructure();
        }
    }

    private void ResetTableStructure()
    {
        TypedContent.TableRows = 2;
        TypedContent.TableColumns = 2;
        TypedContent.HasHeader = true;
        TypedContent.TableStyle = "table table-bordered";
        TypedContent.HeaderCells = new List<string> { "Colonne 1", "Colonne 2" };
        TypedContent.TableCells = new List<List<string>> {
            new List<string> { "Cellule 1,1", "Cellule 1,2" },
            new List<string> { "Cellule 2,1", "Cellule 2,2" }
        };
    }

    private string GetTypeClass()
    {
        var classList = new List<string>();

        if (IsEditing)
        {
            classList.Add("editing");
        }

        if (string.IsNullOrEmpty(TypedContent.TableContent))
        {
            classList.Add("empty");
        }

        return string.Join(" ", classList);
    }

    private async Task RequestDelete()
    {
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Êtes-vous sûr de vouloir supprimer ce bloc tableau ?");
        if (confirmed)
        {
            if (CoursId > 0)
            {
                // Supprimer de la base de données
                bool success = await BlockService.DeleteBlockAsync(Block.Id, CoursId);
                if (success && OnDeleteRequested.HasDelegate)
                {
                    await OnDeleteRequested.InvokeAsync(Block);
                }
            }
            else if (OnDeleteRequested.HasDelegate)
            {
                await OnDeleteRequested.InvokeAsync(Block);
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        _originalContent = null;
        await Task.CompletedTask;
    }

    // **MÉTHODES MANQUANTES AJOUTÉES**

    // Méthode pour valider le bloc avant sauvegarde
    private bool IsValid()
    {
        // Vérifier le titre
        if (!string.IsNullOrEmpty(TypedContent.Title) && TypedContent.Title.Length > 100)
        {
            titleError = true;
            return false;
        }
        
        titleError = false;
        
        // Vérifier la structure du tableau
        if (TypedContent.TableRows < 1 || TypedContent.TableColumns < 1)
        {
            return false;
        }
        
        // Vérifier que le tableau a du contenu
        if (TypedContent.TableCells == null || TypedContent.TableCells.Count == 0)
        {
            return false;
        }
        
        return true;
    }

    // Méthode pour valider le bloc de manière plus approfondie
    private bool ValidateBlock()
    {
        try
        {
            // Vérifier que le contenu est cohérent
            if (TypedContent.TableCells == null)
            {
                return false;
            }
            
            // Vérifier que chaque ligne a le bon nombre de colonnes
            foreach (var row in TypedContent.TableCells)
            {
                if (row == null || row.Count != TypedContent.TableColumns)
                {
                    return false;
                }
            }
            
            // Vérifier les en-têtes si présents
            if (TypedContent.HasHeader && TypedContent.HeaderCells.Count != TypedContent.TableColumns)
            {
                return false;
            }
            
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de la validation: {ex.Message}");
            return false;
        }
    }

    // Méthode pour créer un contenu de tableau par défaut
    private TableBlockContent CreateDefaultTableContent()
    {
        return new TableBlockContent
        {
            Title = string.Empty,
            TableRows = 2,
            TableColumns = 2,
            HasHeader = true,
            TableStyle = "table table-bordered",
            HeaderCells = new List<string> { "Colonne 1", "Colonne 2" },
            TableCells = new List<List<string>> {
                new List<string> { "Cellule 1,1", "Cellule 1,2" },
                new List<string> { "Cellule 2,1", "Cellule 2,2" }
            },
            TableContent = string.Empty
        };
    }

    // Méthode pour valider et corriger la structure du tableau
    private void ValidateAndFixTableStructure()
    {
        try
        {
            // Initialiser les listes si elles sont nulles
            if (TypedContent.HeaderCells == null)
            {
                TypedContent.HeaderCells = new List<string>();
            }
            
            if (TypedContent.TableCells == null)
            {
                TypedContent.TableCells = new List<List<string>>();
            }
            
            // Corriger les dimensions si nécessaire
            if (TypedContent.TableRows < 1) TypedContent.TableRows = 1;
            if (TypedContent.TableColumns < 1) TypedContent.TableColumns = 1;
            
            // Ajuster les en-têtes pour correspondre au nombre de colonnes
            while (TypedContent.HeaderCells.Count < TypedContent.TableColumns)
            {
                TypedContent.HeaderCells.Add($"Colonne {TypedContent.HeaderCells.Count + 1}");
            }
            while (TypedContent.HeaderCells.Count > TypedContent.TableColumns)
            {
                TypedContent.HeaderCells.RemoveAt(TypedContent.HeaderCells.Count - 1);
            }
            
            // Ajuster les lignes pour correspondre au nombre de lignes
            while (TypedContent.TableCells.Count < TypedContent.TableRows)
            {
                var newRow = new List<string>();
                for (int i = 0; i < TypedContent.TableColumns; i++)
                {
                    newRow.Add($"Cellule {TypedContent.TableCells.Count + 1},{i + 1}");
                }
                TypedContent.TableCells.Add(newRow);
            }
            while (TypedContent.TableCells.Count > TypedContent.TableRows)
            {
                TypedContent.TableCells.RemoveAt(TypedContent.TableCells.Count - 1);
            }
            
            // Ajuster chaque ligne pour correspondre au nombre de colonnes
            for (int r = 0; r < TypedContent.TableCells.Count; r++)
            {
                if (TypedContent.TableCells[r] == null)
                {
                    TypedContent.TableCells[r] = new List<string>();
                }
                
                while (TypedContent.TableCells[r].Count < TypedContent.TableColumns)
                {
                    TypedContent.TableCells[r].Add($"Cellule {r + 1},{TypedContent.TableCells[r].Count + 1}");
                }
                while (TypedContent.TableCells[r].Count > TypedContent.TableColumns)
                {
                    TypedContent.TableCells[r].RemoveAt(TypedContent.TableCells[r].Count - 1);
                }
            }
            
            // Vérifier le style du tableau
            if (string.IsNullOrEmpty(TypedContent.TableStyle))
            {
                TypedContent.TableStyle = "table table-bordered";
            }
            
            Console.WriteLine($"Structure validée - Lignes: {TypedContent.TableRows}, Colonnes: {TypedContent.TableColumns}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de la validation de la structure: {ex.Message}");
            ResetTableStructure();
        }
    }

    // Classe pour contenu spécifique à TableBlock
    public class TableBlockContent
    {
        public string Title { get; set; } = string.Empty;
        public int TableRows { get; set; } = 2;
        public int TableColumns { get; set; } = 2;
        public bool HasHeader { get; set; } = true;
        public string TableStyle { get; set; } = "table table-bordered";
        public List<string> HeaderCells { get; set; } = new();
        public List<List<string>> TableCells { get; set; } = new();
        public string TableContent { get; set; } = string.Empty;
    }
}