@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using Mooc.Services
@inject IJSRuntime JSRuntime
@inject RichEditorService EditorService
@implements IAsyncDisposable

<div class="quiz-block @GetTypeClass()" @attributes="AdditionalAttributes">
    <h4 class="quiz-title">
        @if (IsEditing)
        {
            <InputText class="form-control" @bind-Value="Block.Title" placeholder="Titre (optionnel)" />
            @if (titleError)
            {
                <small class="text-danger">Le titre ne peut pas dépasser 100 caractères</small>
            }
            <ValidationMessage For="@(() => Block.Title)" />
        }
        else if (!string.IsNullOrEmpty(Block.Title))
        {
            @Block.Title
        }
        else
        {
            <span class="text-muted">Sans titre</span>
        }
    </h4>
    <div class="quiz-content">
        @if (IsEditing)
        {
            @if (useRichEditor)
            {
                <div id="editor-@Block.Order" class="rich-editor" style="height: 200px;"></div>
            }
            else
            {
                <textarea class="form-control" @bind="TableContent" rows="5" placeholder="Contenu du tableau"></textarea>
            }
            <div class="form-check mt-2">
                <input class="form-check-input" type="checkbox" id="useRichEditor-@Block.Order" 
                       @onchange="ToggleRichEditor" checked="@useRichEditor" />
                <label class="form-check-label" for="useRichEditor-@Block.Order">
                    Utiliser l'éditeur riche
                </label>
            </div>
        }
        else if (!string.IsNullOrEmpty(TableContent))
        {
            <div class="content-display">@((MarkupString)TableContent)</div>
        }
    </div>
    <div class="block-controls mt-3">
        <button class="btn @(IsEditing ? "btn-success" : "btn-primary") btn-sm me-2" @onclick="ToggleEdit">
            <i class="bi bi-@(IsEditing ? "check-lg" : "pencil")"></i> @(IsEditing ? "Enregistrer" : "Modifier")
        </button>
        @if (!IsEditing)
        {
            <button class="btn btn-outline-danger btn-sm" @onclick="RequestDelete" title="Supprimer ce bloc">
                <i class="bi bi-trash"></i>
            </button>
        }
        else
        {
            <button class="btn btn-outline-secondary btn-sm" @onclick="CancelEdit" title="Annuler les modifications">
                <i class="bi bi-x-lg"></i> Annuler
            </button>
        }
    </div>
</div>

@code {
    [Parameter]
    public CoursBlock Block { get; set; } = default!;
    
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }
    
    [Parameter]
    public EventCallback<CoursBlock> OnBlockChanged { get; set; }
    
    [Parameter]
    public EventCallback<CoursBlock> OnDeleteRequested { get; set; }
    
    [CascadingParameter]
    private EditContext? EditContext { get; set; }
    
    private bool IsEditing { get; set; } = false;
    private bool useRichEditor { get; set; } = true;
    private bool titleError { get; set; } = false;
    private string originalContent = string.Empty;
    private string originalTitle = string.Empty;
    private string editorId => $"editor-{Block.Order}";

    // Property to handle content as string, using Block.Content
    private string TableContent 
    { 
        get => Block.Content?.ToString() ?? string.Empty;
        set => Block.Content = value;
    }

    protected override void OnInitialized()
    {
        // Initialiser le contenu si nécessaire
        if (Block.Content == null)
        {
            Block.Content = string.Empty;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (IsEditing && useRichEditor)
        {
            // Initialiser l'éditeur riche
            await EditorService.InitializeEditorAsync(editorId, TableContent);
            
            // S'abonner aux changements de contenu
            EditorInterop.SubscribeToContentChanges(editorId, OnContentChanged);
        }
    }

    // Cette méthode sera appelée lorsque le contenu de l'éditeur change
    private void OnContentChanged(string elementId, string content)
    {
        // Mettre à jour le contenu du bloc
        TableContent = content;
    }

    private string GetTypeClass()
    {
        var classList = new List<string>();
        
        // Ajouter la classe basée sur le type
        classList.Add(Block.Type switch
        {
            "table" => "table-block",
            _ => "default-block"
        });
        
        if (IsEditing)
        {
            classList.Add("editing");
        }
        
        if (string.IsNullOrEmpty(TableContent))
        {
            classList.Add("empty");
        }
        
        return string.Join(" ", classList);
    }

    private async Task ToggleEdit()
    {
        if (IsEditing)
        {
            // Validation avant de sauvegarder
            if (Block.Title?.Length > 100)
            {
                titleError = true;
                return;
            }

            // Si on utilise l'éditeur riche, récupérer le contenu depuis JS
            if (useRichEditor)
            {
                TableContent = await EditorService.GetEditorContentAsync(editorId);
            }

            // Notifier le parent que le bloc a changé
            if (OnBlockChanged.HasDelegate)
            {
                await OnBlockChanged.InvokeAsync(Block);
            }
            
            // Notifier le contexte d'édition si nécessaire
            EditContext?.NotifyFieldChanged(new FieldIdentifier(Block, nameof(Block.Title)));
            EditContext?.NotifyFieldChanged(new FieldIdentifier(Block, nameof(Block.Content)));
            
            IsEditing = false;
        }
        else
        {
            // Sauvegarder l'état original pour permettre d'annuler
            originalContent = TableContent;
            originalTitle = Block.Title ?? string.Empty;
            
            IsEditing = true;
        }

        titleError = false;
    }
    
    private async Task ToggleRichEditor()
    {
        useRichEditor = !useRichEditor;
        
        if (IsEditing)
        {
            if (useRichEditor)
            {
                // Transférer le contenu du textarea à l'éditeur riche
                await EditorService.InitializeEditorAsync(editorId, TableContent);
                EditorInterop.SubscribeToContentChanges(editorId, OnContentChanged);
            }
            else
            {
                // Transférer le contenu de l'éditeur riche au textarea
                TableContent = await EditorService.GetEditorContentAsync(editorId);
                await EditorService.DestroyEditorAsync(editorId);
                EditorInterop.UnsubscribeFromContentChanges(editorId);
            }
        }
        
        StateHasChanged();
    }

    private async Task CancelEdit()
    {
        // Restaurer le contenu original
        TableContent = originalContent;
        Block.Title = originalTitle;
        
        // Nettoyer l'éditeur si nécessaire
        if (useRichEditor)
        {
            await EditorService.DestroyEditorAsync(editorId);
            EditorInterop.UnsubscribeFromContentChanges(editorId);
        }
        
        IsEditing = false;
        
        // Notifier le contexte d'édition
        EditContext?.NotifyFieldChanged(new FieldIdentifier(Block, nameof(Block.Title)));
        EditContext?.NotifyFieldChanged(new FieldIdentifier(Block, nameof(Block.Content)));
    }

    private async Task RequestDelete()
    {
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Êtes-vous sûr de vouloir supprimer ce tableau?");
        if (confirmed && OnDeleteRequested.HasDelegate)
        {
            await OnDeleteRequested.InvokeAsync(Block);
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Nettoyer les ressources lors de la suppression du composant
        if (useRichEditor && IsEditing)
        {
            await EditorService.DestroyEditorAsync(editorId);
            EditorInterop.UnsubscribeFromContentChanges(editorId);
        }
    }
}
