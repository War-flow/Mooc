@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using Mooc.Services
@inject IJSRuntime JSRuntime
@inject RichEditorService EditorService
@implements IAsyncDisposable

<div class="space-block @GetTypeClass()" id="block-@Block.Order">
    <h4 class="space-title @(string.IsNullOrEmpty(Block.Title) ? "text-muted" : "")">
        @if (IsEditing)
        {
            <InputText class="form-control" @bind-Value="Block.Title" placeholder="Titre (optionnel)" />
            @if (titleError)
            {
                <small class="text-danger">Le titre ne peut pas dépasser 100 caractères</small>
            }
        }
        else if (!string.IsNullOrEmpty(Block.Title))
        {
            @Block.Title
        }
        else
        {
            <span class="text-muted">Sans titre</span>
        }
    </h4>
    <div class="space-content">
        @if (IsEditing)
        {
            if (useRichEditor)
            {
                <div id="@editorId" class="rich-editor" style="height: 200px;"></div>
            }
            else
            {
                <InputTextArea class="form-control" @bind-Value="Block.Text" rows="5" placeholder="Contenu du texte" />
            }
            <div class="form-check mt-2">
                <input class="form-check-input" type="checkbox" id="@($"useRichEditor-{Block.Order}")"
                       @onchange="ToggleRichEditor" checked="@useRichEditor" />
                <label class="form-check-label" for="@($"useRichEditor-{Block.Order}")">
                    Utiliser l'éditeur riche
                </label>
            </div>
        }
        else
        {
            <div class="content-display">@((MarkupString)Block.Text)</div>
        }
    </div>
    <div class="block-controls mt-3">
        <button class="btn @(IsEditing ? "btn-success" : "btn-primary") btn-sm me-2" @onclick="ToggleEdit">
            <i class="bi bi-@(IsEditing ? "check-lg" : "pencil")"></i> @(IsEditing ? "Enregistrer" : "Modifier")
        </button>
        @if (!IsEditing)
        {
            <button class="btn btn-outline-danger btn-sm" @onclick="RequestDelete" title="Supprimer ce bloc">
                <i class="bi bi-trash"></i>
            </button>
        }
        else
        {
            <button class="btn btn-outline-secondary btn-sm" @onclick="CancelEdit" title="Annuler les modifications">
                <i class="bi bi-x-lg"></i> Annuler
            </button>
        }
    </div>
</div>

@code {
    [Parameter]
    public CoursBlock Block { get; set; } = default!;
    
    [Parameter]
    public EventCallback<CoursBlock> OnDelete { get; set; }
    
    [Parameter]
    public EventCallback<CoursBlock> OnBlockChanged { get; set; }
    
    [Parameter]
    public bool IsEditing { get; set; } = false;
    
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }
    
    private bool useRichEditor = true;
    private string editorId => $"editor-{Block.Order}";
    private bool titleError = false;
    private string originalContent = string.Empty;
    private string originalTitle = string.Empty;
    
    protected override void OnInitialized()
    {
        // Initialiser le contenu si nécessaire
        if (Block.Text == null)
        {
            Block.Text = string.Empty;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (IsEditing && useRichEditor)
        {
            // Initialiser l'éditeur riche
            await EditorService.InitializeEditorAsync(editorId, Block.Text);
            
            // S'abonner aux changements de contenu
            EditorInterop.SubscribeToContentChanges(editorId, OnContentChanged);
        }
    }
    
    // Cette méthode sera appelée lorsque le contenu de l'éditeur change
    private void OnContentChanged(string elementId, string content)
    {
        // Mettre à jour le contenu du bloc
        Block.Text = content;
    }
    
    private string GetTypeClass()
    {
        var classList = new List<string>();
        
        // Ajouter la classe basée sur le type
        classList.Add(Block.Type switch
        {
            "separateur" => "separator-block",
            _ => "unknown-block"
        });
        
        if (IsEditing)
        {
            classList.Add("editing");
        }
        
        if (string.IsNullOrEmpty(Block.Text))
        {
            classList.Add("empty");
        }
        
        return string.Join(" ", classList);
    }
    
    private async Task ToggleEdit()
    {
        if (IsEditing)
        {
            // Validation avant de sauvegarder
            if (Block.Title?.Length > 100)
            {
                titleError = true;
                return;
            }
            
            titleError = false;
            
            // Si on utilise l'éditeur riche, récupérer le contenu depuis JS
            if (useRichEditor)
            {
                Block.Text = await EditorService.GetEditorContentAsync(editorId);
            }
            
            // Notifier le parent que le bloc a changé
            await OnBlockChanged.InvokeAsync(Block);
        }
        else
        {
            // Sauvegarder l'état original pour permettre d'annuler
            originalContent = Block.Text ?? string.Empty;
            originalTitle = Block.Title ?? string.Empty;
        }
        
        IsEditing = !IsEditing;
    }
    
    private async Task ToggleRichEditor()
    {
        useRichEditor = !useRichEditor;
        
        if (IsEditing)
        {
            if (useRichEditor)
            {
                // Transférer le contenu du textarea à l'éditeur riche
                await EditorService.InitializeEditorAsync(editorId, Block.Text);
                EditorInterop.SubscribeToContentChanges(editorId, OnContentChanged);
            }
            else
            {
                // Transférer le contenu de l'éditeur riche au textarea
                Block.Text = await EditorService.GetEditorContentAsync(editorId);
                await EditorService.DestroyEditorAsync(editorId);
                EditorInterop.UnsubscribeFromContentChanges(editorId);
            }
        }
        
        StateHasChanged();
    }
    
    private async Task CancelEdit()
    {
        // Restaurer le contenu original
        Block.Text = originalContent;
        Block.Title = originalTitle;
        
        // Nettoyer l'éditeur si nécessaire
        if (useRichEditor)
        {
            await EditorService.DestroyEditorAsync(editorId);
            EditorInterop.UnsubscribeFromContentChanges(editorId);
        }
        
        IsEditing = false;
    }

    private async Task RequestDelete()
    {
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Êtes-vous sûr de vouloir supprimer ce bloc?");
        if (confirmed)
        {
            await OnDelete.InvokeAsync(Block);
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Nettoyer les ressources lors de la suppression du composant
        if (useRichEditor && IsEditing)
        {
            await EditorService.DestroyEditorAsync(editorId);
            EditorInterop.UnsubscribeFromContentChanges(editorId);
        }
    }
}
