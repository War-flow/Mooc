@page "/manager/cms/block/text/{blockId:int}"
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using Mooc.Services
@using static Mooc.Components.Pages.Manager.CMS.CourBuilder
@inject IJSRuntime JSRuntime
@using Mooc.Components.Shared

@using System.ComponentModel.DataAnnotations

<EditForm Model="TypedContent" OnValidSubmit="HandleValidSubmit">
    <DataAnnotationsValidator />
    <ValidationSummary />

    <div class="text-block @GetTypeClass()" id="block-@Block.Order">
        <h4 class="text-title @(string.IsNullOrEmpty(TypedContent.Title) ? "text-muted" : "")">
            @if (IsEditing)
            {
                <InputText class="form-control" @bind-Value="TypedContent.Title" placeholder="Titre (optionnel)" />
            }
            else if (!string.IsNullOrEmpty(TypedContent.Title))
            {
                @TypedContent.Title
            }
        </h4>

        <div class="text-content">
            @if (IsEditing)
            {
                @if (useRichEditor)
                {
                    <RichEditor 

                    Value="@TypedContent.Text" 
                    ValueChanged="@OnTextContentChanged" 
                    Height="@EditorHeight"
                    Placeholder="Saisissez le contenu de votre bloc..." 
                    MaxLength="10000" 
                    EditorId="@editorId"
                    ShowCharacterCount="true" 
                    
                    />
                }
                else
                {
                    <InputTextArea class="form-control" @bind-Value="TypedContent.Text" rows="5" />
                }
                
            }
            else
            {
                <div class="text-message">
                    @((MarkupString)TypedContent.Text)
                </div>
            }
        </div>

        <div class="block-controls mt-2">
            <button type="button" class="btn-block btn-valid"
                    @onclick="ToggleEdit" disabled="@(IsEditing && !IsValid())"
                    aria-label="@(IsEditing ? "Enregistrer les modifications" : "Modifier le bloc")">
                <i class="bi bi-@(IsEditing ? "floppy" : "pencil")"></i>
                @(IsEditing ? "Enregistrer" : "Modifier")
            </button>
            
            @if (IsEditing)
            {
                <button type="button" class="btn-block btn-cancel" @onclick="CancelEdit"
                        aria-label="Annuler les modifications">
                    <i class="bi bi-x-lg"></i> Annuler
                </button>
            }
            else
            {
                <button type="button" class="btn-block btn-cancel" @onclick="RequestDelete"
                        title="Supprimer ce bloc">
                    <i class="bi bi-trash"> Supprimer</i>
                </button>
            }
        </div>

        <!-- Indicateur de sauvegarde -->
        @if (isSaving)
        {
            <div class="save-indicator">
                <span class="spinner-border spinner-border-sm text-primary" role="status"></span>
                <span class="ms-1">Sauvegarde en cours...</span>
            </div>
        }

        <!-- Message de succès temporaire -->
        @if (showSaveSuccess)
        {
            <div class="alert alert-success mt-2 p-2 fade-out">
                Modifications enregistrées avec succès
            </div>
        }

        <!-- Message d'erreur -->
        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <div class="alert alert-danger mt-2 p-2">
                @errorMessage
            </div>
        }
    </div>
</EditForm>

@code {
    [Parameter]
    public int BlockId { get; set; }

    [Parameter]
    public dynamic Block { get; set; }

    [Parameter]
    public int CoursId { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnBlockChanged { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnDeleteRequested { get; set; }

    [Parameter]
    public bool IsEditing { get; set; } = false;

    [Parameter]
    public EventCallback<bool> OnEditStateChanged { get; set; }

    private bool useRichEditor { get; set; } = true;
    private bool titleError { get; set; } = false;
    private string editorId => Block != null ? $"editor-{Block.Order}" : "editor-temp";
    private bool isSaving { get; set; } = false;
    private bool showSaveSuccess { get; set; } = false;
    private bool editorInitialized { get; set; } = false;

    [Parameter]
    public int EditorHeight { get; set; } = 300;

    private Timer? autoSaveTimer;
    private bool hasUnsavedChanges = false;

    private string? errorMessage;
    private bool hasValidationErrors => !string.IsNullOrEmpty(errorMessage) || titleError;

    private TextBlockContent? _originalContent;

    private TextBlockContent TypedContent => Block.Content as TextBlockContent ?? new TextBlockContent();

    protected override void OnInitialized()
    {
        base.OnInitialized();
        EnsureContentInitialized();
        
        if (Block == null)
        {
            var newBlock = new CoursBlock
            {
                Type = "texte",
                Title = string.Empty,
                Order = 0
            };
            Block = newBlock;
        }

        Console.WriteLine($"TextBlock OnInitialized - CoursId: {CoursId}, Block.Id: {Block?.Id}");
    }

    protected override void OnParametersSet()
    {
        EnsureContentInitialized();
        Console.WriteLine($"TextBlock OnParametersSet - CoursId: {CoursId}, Block.Id: {Block?.Id}");
    }

    private void EnsureContentInitialized()
    {
        if (Block?.Content is not TextBlockContent)
        {
            Block.Content = new TextBlockContent
            {
                Title = Block?.Title ?? string.Empty,
                Text = Block?.Text ?? string.Empty
            };
        }
    }

    private async Task OnTextContentChanged(string newContent)
    {
        TypedContent.Text = newContent;
        hasUnsavedChanges = true;
        StateHasChanged();
    }

    private bool IsValid()
    {
        return !string.IsNullOrWhiteSpace(TypedContent.Text);
    }

    private async Task ToggleEdit()
    {
        if (IsEditing)
        {
            if (!IsValid())
                return;

            try
            {
                isSaving = true;
                StateHasChanged();

                Block.Title = TypedContent.Title;
                Block.Text = TypedContent.Text;
                
                if (CoursId > 0)
                {
                    Console.WriteLine($"TextBlock: Sauvegarde pour CoursId: {CoursId}");
                }
                
                _originalContent = null;
                IsEditing = false;
                
                await OnBlockChanged.InvokeAsync(Block);
                
                showSaveSuccess = true;
                StateHasChanged();
                
                await Task.Delay(2000);
                showSaveSuccess = false;
            }
            catch (Exception ex)
            {
                errorMessage = "Erreur lors de la sauvegarde. Veuillez réessayer.";
                Console.WriteLine($"Erreur lors de la sauvegarde: {ex.Message}");
            }
            finally
            {
                isSaving = false;
                StateHasChanged();
            }
        }
        else
        {
            _originalContent = new TextBlockContent
            {
                Title = TypedContent.Title,
                Text = TypedContent.Text
            };
            
            IsEditing = true;
            await OnEditStateChanged.InvokeAsync(IsEditing);
            StateHasChanged();
        }
    }

    private async Task CancelEdit()
    {
        try
        {
            if (_originalContent != null)
            {
                Block.Content = _originalContent;
                Block.Title = _originalContent.Title;
                Block.Text = _originalContent.Text;
                _originalContent = null;
            }
        
            IsEditing = false;
            hasUnsavedChanges = false;
            errorMessage = null;
            titleError = false;
        
            StateHasChanged();
            await Task.Delay(100);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de l'annulation: {ex.Message}");
            errorMessage = "Erreur lors de l'annulation des modifications";
        }
    }

    private async Task RequestDelete()
    {
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Êtes-vous sûr de vouloir supprimer ce bloc de texte ?");
        if (confirmed)
        {
            if (CoursId > 0)
            {
                Console.WriteLine($"TextBlock: Suppression pour CoursId: {CoursId}");
            }

            await OnDeleteRequested.InvokeAsync(Block);
        }
    }
     
    private string GetTypeClass() =>
        $"{(IsEditing ? "editing" : "")} {(string.IsNullOrEmpty(TypedContent.Text) ? "empty" : "")}".Trim();

    public class TextBlockContent
    {
        [MaxLength(100, ErrorMessage = "Le titre ne peut pas dépasser 100 caractères")]
        public string Title { get; set; } = string.Empty;

        [Required(ErrorMessage = "Le contenu ne peut pas être vide")]
        [MaxLength(10000, ErrorMessage = "Le contenu ne peut pas dépasser 10 000 caractères")]
        public string Text { get; set; } = string.Empty;
    }

    private async Task HandleValidSubmit()
    {
        await ToggleEdit();
    }
}