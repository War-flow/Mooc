@page "/manager/cms/block/text/{blockId:int}"
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.EntityFrameworkCore
@using Microsoft.JSInterop
@using Mooc.Data
@using Mooc.Services
@using static Mooc.Components.Pages.Manager.CMS.CourBuilder
@inject IJSRuntime JSRuntime
@using Mooc.Components.Shared
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@implements IAsyncDisposable

@using System.ComponentModel.DataAnnotations
@using System.Text.Json

<EditForm Model="TypedContent" OnValidSubmit="HandleValidSubmit">
    <DataAnnotationsValidator />
    <ValidationSummary />

    <div class="text-block @GetTypeClass()" id="block-@Block.Order">
        <h4 class="text-title @(string.IsNullOrEmpty(TypedContent.Title) ? "text-muted" : "")">
            @if (IsEditing)
            {
                <InputText class="form-control" @bind-Value="TypedContent.Title" placeholder="Titre (optionnel)" />
            }
            else if (!string.IsNullOrEmpty(TypedContent.Title))
            {
                @TypedContent.Title
            }
        </h4>

        <div class="text-content">
            @if (IsEditing)
            {
                @if (useRichEditor)
                {
                    <RichEditor @ref="richEditorRef"
                        Value="@TypedContent.Text" 
                        ValueChanged="@OnTextContentChanged" 
                        Height="@EditorHeight"
                        Placeholder="Saisissez le contenu de votre bloc..." 
                        MaxLength="10000" 
                        EditorId="@editorId"
                        ShowCharacterCount="true" 
                        ShowToolbar="true"
                    />
                }
                else
                {
                    <InputTextArea class="form-control" @bind-Value="TypedContent.Text" rows="5" />
                }
            }
            else
            {
                <div class="text-message">
                    @if (!string.IsNullOrEmpty(TypedContent.Text))
                    {
                        @((MarkupString)SanitizeHtmlContent(TypedContent.Text))
                    }
                    else
                    {
                        <em class="text-muted">Aucun contenu</em>
                    }
                </div>
            }
        </div>

        <div class="block-controls mt-2">
            <button type="button" class="btn-block btn-valid"
                    @onclick="ToggleEdit" disabled="@(IsEditing && !IsValid())"
                    aria-label="@(IsEditing ? "Enregistrer les modifications" : "Modifier le bloc")">
                <i class="bi bi-@(IsEditing ? "floppy" : "pencil")"></i>
                @(IsEditing ? "Enregistrer" : "Modifier")
            </button>
            
            @if (IsEditing)
            {
                <button type="button" class="btn-block btn-cancel" @onclick="CancelEdit"
                        aria-label="Annuler les modifications">
                    <i class="bi bi-x-lg"></i> Annuler
                </button>
            }
            else
            {
                <button type="button" class="btn-block btn-cancel" @onclick="RequestDelete"
                        title="Supprimer ce bloc">
                    <i class="bi bi-trash"> Supprimer</i>
                </button>
            }
        </div>

        <!-- Indicateurs d'état -->
        @if (isSaving)
        {
            <div class="save-indicator">
                <span class="spinner-border spinner-border-sm text-primary" role="status"></span>
                <span class="ms-1">Sauvegarde en cours...</span>
            </div>
        }

        @if (showSaveSuccess)
        {
            <div class="alert alert-success mt-2 p-2 fade-out">
                <i class="bi bi-check-circle-fill"></i>
                Modifications enregistrées avec succès
            </div>
        }

        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <div class="alert alert-danger mt-2 p-2" role="alert">
                <i class="bi bi-exclamation-triangle-fill"></i>
                @errorMessage
                <button type="button" class="btn-close btn-close-sm ms-2" @onclick="ClearError" aria-label="Fermer"></button>
            </div>
        }
    </div>
</EditForm>

@code {
    // === Paramètres ===
    [Parameter] public int BlockId { get; set; }
    [Parameter] public dynamic Block { get; set; }
    [Parameter] public int CoursId { get; set; }
    [Parameter] public EventCallback<CourBuilder.CoursBlock> OnBlockChanged { get; set; }
    [Parameter] public EventCallback<CourBuilder.CoursBlock> OnDeleteRequested { get; set; }
    [Parameter] public bool IsEditing { get; set; } = false;
    [Parameter] public EventCallback<bool> OnEditStateChanged { get; set; }
    [Parameter] public int EditorHeight { get; set; } = 300;

    // === État du composant ===
    private bool useRichEditor { get; set; } = true;
    private bool isSaving { get; set; } = false;
    private bool showSaveSuccess { get; set; } = false;
    private RichEditor? richEditorRef;
    private string? errorMessage;
    private TextBlockContent? _originalContent;
    private CancellationTokenSource? _autoSaveCts;
    private Timer? _successMessageTimer;

    // === Propriétés calculées ===
    private string editorId => Block != null ? $"editor-{Block.Order}" : "editor-temp";
    private TextBlockContent TypedContent => Block.Content as TextBlockContent ?? new TextBlockContent();

    protected override void OnInitialized()
    {
        EnsureContentInitialized();
        InitializeBlock();
    }

    protected override void OnParametersSet()
    {
        // Optimisation : éviter les re-rendus inutiles
        if (Block?.Content is not TextBlockContent)
        {
            EnsureContentInitialized();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender && !IsEditing && TypedContent.Text.Contains("<img"))
        {
            await EnhanceImageDisplay();
        }
    }

    private void InitializeBlock()
    {
        if (Block == null)
        {
            Block = new CoursBlock
            {
                Type = "texte",
                Title = string.Empty,
                Order = 0
            };
        }
    }

    private void EnsureContentInitialized()
    {
        if (Block?.Content is not TextBlockContent)
        {
            Block.Content = new TextBlockContent
            {
                Title = Block?.Title ?? string.Empty,
                Text = Block?.Text ?? string.Empty
            };
        }
    }

    private async Task EnhanceImageDisplay()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("enhanceImageDisplay");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur amélioration images: {ex.Message}");
        }
    }

    private string SanitizeHtmlContent(string htmlContent)
    {
        if (string.IsNullOrEmpty(htmlContent))
            return string.Empty;
            
        var cleaned = htmlContent
            .Replace("<div style=\"color: #6c757d; font-style: italic;\">Commencez à écrire...</div>", "")
            .Replace("<div style=\"color: #6c757d; font-style: italic;\">Saisissez le contenu de votre bloc...</div>", "");
            
        return cleaned.Trim();
    }

    private async Task OnTextContentChanged(string newContent)
    {
        var contentToSave = PreserveImagesInContent(newContent);
        TypedContent.Text = contentToSave;
        
        // Debounce pour éviter trop d'appels
        _autoSaveCts?.Cancel();
        _autoSaveCts = new CancellationTokenSource();
        
        try
        {
            await Task.Delay(500, _autoSaveCts.Token);
            StateHasChanged();
        }
        catch (OperationCanceledException)
        {
            // Annulé, normal
        }
    }

    private string PreserveImagesInContent(string content)
    {
        if (content.Contains("<img"))
        {
            return content
                .Replace("<div style=\"color: #6c757d; font-style: italic;\">Commencez à écrire...</div>", "")
                .Replace("<div style=\"color: #6c757d; font-style: italic;\">Saisissez le contenu de votre bloc...</div>", "");
        }
        
        return SanitizeHtmlContent(content);
    }

    private bool IsValid()
    {
        return !string.IsNullOrWhiteSpace(TypedContent.Text) || 
               TypedContent.Text.Contains("<img") ||
               !string.IsNullOrWhiteSpace(TypedContent.Title);
    }

    private async Task ToggleEdit()
    {
        if (IsEditing)
        {
            await SaveChanges();
        }
        else
        {
            await StartEditing();
        }
    }

    private async Task StartEditing()
    {
        // Sauvegarder l'état original
        _originalContent = new TextBlockContent
        {
            Title = TypedContent.Title,
            Text = TypedContent.Text
        };
        
        IsEditing = true;
        await OnEditStateChanged.InvokeAsync(IsEditing);
        ClearError();
    }

    private async Task SaveChanges()
    {
        if (!IsValid())
        {
            errorMessage = "Le contenu ne peut pas être vide.";
            return;
        }

        try
        {
            isSaving = true;
            ClearError();

            Block.Title = TypedContent.Title;
            Block.Text = TypedContent.Text;

            // Mise à jour du contenu sérialisable
            if (Block.Content is TextBlockContent content)
            {
                content.Text = TypedContent.Text;
                content.Title = TypedContent.Title;
            }

            if (CoursId > 0)
            {
                var blockService = new Mooc.Services.BlockService(DbContextFactory);
                bool success = await blockService.SaveBlockAsync(Block, CoursId);

                if (!success)
                {
                    errorMessage = "Erreur lors de la sauvegarde.";
                    return;
                }

                await VerifyImageSave();
            }

            _originalContent = null;
            IsEditing = false;

            await OnBlockChanged.InvokeAsync(Block);
            await ShowSuccessMessage();
            
            // Améliorer l'affichage après sauvegarde
            await Task.Delay(100);
            await EnhanceImageDisplay();
        }
        catch (Exception ex)
        {
            errorMessage = "Erreur lors de la sauvegarde. Veuillez réessayer.";
            Console.WriteLine($"Erreur sauvegarde: {ex.Message}");
        }
        finally
        {
            isSaving = false;
            StateHasChanged();
        }
    }

    private async Task ShowSuccessMessage()
    {
        showSaveSuccess = true;
        StateHasChanged();

        _successMessageTimer?.Dispose();
        _successMessageTimer = new Timer(_ => InvokeAsync(() =>
        {
            showSaveSuccess = false;
            StateHasChanged();
        }), null, TimeSpan.FromSeconds(3), Timeout.InfiniteTimeSpan);
    }

    private async Task CancelEdit()
    {
        try
        {
            if (_originalContent != null)
            {
                // Restaurer le contenu original
                Block.Content = _originalContent;
                Block.Title = _originalContent.Title;
                Block.Text = _originalContent.Text;
                _originalContent = null;
            }

            IsEditing = false;
            ClearError();
            await OnEditStateChanged.InvokeAsync(IsEditing);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur annulation: {ex.Message}");
            errorMessage = "Erreur lors de l'annulation des modifications";
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task RequestDelete()
    {
        try
        {
            bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", 
                "Êtes-vous sûr de vouloir supprimer ce bloc de texte ?");
            
            if (confirmed)
            {
                await OnDeleteRequested.InvokeAsync(Block);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur suppression: {ex.Message}");
            errorMessage = "Erreur lors de la suppression";
        }
    }

    private void ClearError()
    {
        errorMessage = null;
        StateHasChanged();
    }

    private async Task VerifyImageSave()
    {
        try
        {
            await Task.Delay(500);
            
            using var context = await DbContextFactory.CreateDbContextAsync();
            var cours = await context.Courses.FindAsync(CoursId);
            
            if (cours?.Content != null)
            {
                var blocksFromDb = JsonSerializer.Deserialize<List<CourBuilder.CoursBlock>>(cours.Content) ?? new();
                var savedBlock = blocksFromDb.FirstOrDefault(b => b.Id == Block.Id);
                
                if (savedBlock?.Text?.Contains("/uploads/images/") == true)
                {
                    Console.WriteLine("✅ Image sauvegardée avec succès");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur vérification: {ex.Message}");
        }
    }

    private string GetTypeClass() =>
        $"{(IsEditing ? "editing" : "")} {(string.IsNullOrEmpty(TypedContent.Text) ? "empty" : "")}".Trim();

    private async Task HandleValidSubmit()
    {
        await ToggleEdit();
    }

    public async ValueTask DisposeAsync()
    {
        _autoSaveCts?.Cancel();
        _autoSaveCts?.Dispose();
        _successMessageTimer?.Dispose();
    }

    public class TextBlockContent
    {
        [MaxLength(100, ErrorMessage = "Le titre ne peut pas dépasser 100 caractères")]
        public string Title { get; set; } = string.Empty;

        [Required(ErrorMessage = "Le contenu ne peut pas être vide")]
        [MaxLength(10000, ErrorMessage = "Le contenu ne peut pas dépasser 10 000 caractères")]
        public string Text { get; set; } = string.Empty;
    }
}