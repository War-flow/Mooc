@page "/manager/cms/block/text/{blockId:int}"
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using Mooc.Services
@using Mooc.Components.Pages.Manager.CMS.Block
@inject IJSRuntime JSRuntime
@inject RichEditorService EditorService
@implements IAsyncDisposable


@if (Block != null)
{
    <div class="text-block @GetTypeClass()" id="block-@Block.Order">
        <h4 class="text-title @(string.IsNullOrEmpty(GetBlockTitle()) ? "text-muted" : "")">
            @if (IsEditing)
            {
                <input type="text" class="form-control" value="@GetBlockTitle()" @oninput="OnTitleChanged" />
                @if (titleError)
                {
                    <small class="text-danger">Le titre ne peut pas dépasser 100 caractères</small>
                }   
            }
            else if (!string.IsNullOrEmpty(GetBlockTitle()))
            {
                @GetBlockTitle()
            }
            else
            {
                <span class="text-muted">Bloc Text (vide)</span>
            }
        </h4>
        <div class="text-content">
            @if (IsEditing)
            {
                @if (useRichEditor)
                {
                    <div id="editor-@Block.Order" class="rich-editor" style="height: @(EditorHeight)px;"></div>
                }
                else
                {
                    <textarea class="form-control" value="@GetBlockText()" @oninput="OnTextChanged" rows="5"></textarea>
                }
                <div class="form-check mt-2">
                    <input class="form-check-input" type="checkbox" id="useRichEditor-@Block.Order"
                           @onchange="ToggleRichEditor" checked="@useRichEditor" />
                    <label class="form-check-label" for="useRichEditor-@Block.Order">
                        Utiliser l'éditeur riche
                    </label>
                </div>
            }
            else
            {
                <div class="content-display">@((MarkupString)GetBlockText())</div>
            }
        </div>
        <div class="block-controls">

            <button type="button" class="btn-block btn-valid" @onclick="ToggleEdit">
                <i class="bi bi-@(IsEditing ? "floppy" : "pencil")"></i> @(IsEditing ? "Enregistrer" : "Modifier")
            </button>

            <button id="delete-btn-@(Block.Id)" type="button" class="btn-block btn-cancel" @onclick="RequestDelete" title="Supprimer ce bloc">
                <i class="bi bi-trash"> Supprimer</i>
            </button>
        </div>

        <!-- Indicateur de sauvegarde -->
        @if (isSaving)
        {
            <div class="save-indicator">
                <span class="spinner-border spinner-border-sm text-primary" role="status"></span>
                <span class="ms-1">Sauvegarde en cours...</span>
            </div>
        }

        <!-- Message de succès temporaire -->
        @if (showSaveSuccess)
        {
            <div class="alert alert-success mt-2 p-2 fade-out">
                Modifications enregistrées avec succès
            </div>
        }
    </div>
}
else
{
    <div class="alert alert-warning">
        Chargement du bloc de texte en cours...
    </div>
}

@code {
    [Parameter]
    public int BlockId { get; set; }

    [Parameter]
    public dynamic Block { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnBlockChanged { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnDeleteRequested { get; set; }

    private bool IsEditing { get; set; } = false;
    private bool useRichEditor { get; set; } = true;
    private bool titleError { get; set; } = false;
    private string originalContent = string.Empty;
    private string originalTitle = string.Empty;
    private string editorId => Block != null ? $"editor-{Block.Order}" : "editor-temp";
    private bool isSaving { get; set; } = false;
    private bool showSaveSuccess { get; set; } = false;

    // Ajouter propriété pour la hauteur de l'éditeur
    [Parameter]
    public int EditorHeight { get; set; } = 200;

    protected override void OnInitialized()
    {
        // S'assurer que Block n'est pas null
        if (Block == null)
        {
            // Créer un objet CoursBlock avec les propriétés minimales requises
            var newBlock = new CoursBlock
            {
                Type = "texte",
                Title = string.Empty,
                Order = 0
            };
            Block = newBlock;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (Block != null && IsEditing && useRichEditor)
        {
            await InitializeRichEditor();
        }
    }

    // Méthode améliorée pour initialiser l'éditeur
    private async Task InitializeRichEditor()
    {
        if (Block == null || !IsEditing || !useRichEditor) return;
        
        try
        {
            string content = GetBlockText();
            // Initialiser l'éditeur riche avec la hauteur configurable
            await EditorService.InitializeEditorAsync(editorId, content);
            
            // S'abonner aux changements de contenu
            EditorInterop.SubscribeToContentChanges(editorId, OnContentChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de l'initialisation de l'éditeur: {ex.Message}");
        }
    }

    // Cette méthode sera appelée lorsque le contenu de l'éditeur change
    private void OnContentChanged(string elementId, string content)
    {
        if (Block != null)
        {
            try
            {
                UpdateBlockText(content);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur lors de la mise à jour du contenu: {ex.Message}");
            }
        }
    }

    // Méthode pour gérer le changement de texte dans le textarea
    private void OnTextChanged(ChangeEventArgs e)
    {
        if (Block != null && e.Value != null)
        {
            string value = e.Value.ToString() ?? string.Empty;
            UpdateBlockText(value);
        }
    }

    // Méthode pour gérer le changement de titre
    private void OnTitleChanged(ChangeEventArgs e)
    {
        if (Block != null && e.Value != null)
        {
            string value = e.Value.ToString() ?? string.Empty;
            
            if (value.Length > 100)
            {
                titleError = true;
                return;
            }
            titleError = false;
            UpdateBlockTitle(value);
        }
    }

    // Méthode améliorée pour sauvegarder les modifications
    private async Task SaveChanges()
    {
        if (Block == null) return;
        
        try
        {
            // Validation avant de sauvegarder
            if (GetBlockTitle().Length > 100)
            {
                titleError = true;
                return;
            }

            isSaving = true;
            StateHasChanged();

            // Si on utilise l'éditeur riche, récupérer le contenu depuis JS
            if (useRichEditor)
            {
                string editorContent = await EditorService.GetEditorContentAsync(editorId);
                UpdateBlockText(editorContent);
            }

            // Notifier le parent que le bloc a changé
            await OnBlockChanged.InvokeAsync(Block);
            
            // Afficher le message de succès temporairement
            showSaveSuccess = true;
            StateHasChanged();
            
            await Task.Delay(2000);
            showSaveSuccess = false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de la sauvegarde des modifications: {ex.Message}");
            // Afficher un message d'erreur à l'utilisateur serait pertinent ici
        }
        finally
        {
            isSaving = false;
            StateHasChanged();
        }
    }

    private async Task ToggleEdit()
    {
        if (Block == null) return;
        
        if (IsEditing)
        {
            await SaveChanges();
        }
        else
        {
            // Sauvegarder l'état original pour permettre d'annuler
            originalContent = GetBlockText();
            originalTitle = GetBlockTitle();
        }

        titleError = false;
        IsEditing = !IsEditing;
    }
    
    private async Task ToggleRichEditor()
    {
        if (Block == null) return;
        
        useRichEditor = !useRichEditor;
        
        if (IsEditing)
        {
            try
            {
                if (useRichEditor)
                {
                    // Transférer le contenu du textarea à l'éditeur riche
                    await EditorService.InitializeEditorAsync(editorId, GetBlockText());
                    EditorInterop.SubscribeToContentChanges(editorId, OnContentChanged);
                }
                else
                {
                    // Transférer le contenu de l'éditeur riche au textarea
                    string editorContent = await EditorService.GetEditorContentAsync(editorId);
                    UpdateBlockText(editorContent);
                    await EditorService.DestroyEditorAsync(editorId);
                    EditorInterop.UnsubscribeFromContentChanges(editorId);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur lors du basculement de l'éditeur: {ex.Message}");
            }
        }
        
        StateHasChanged();
    }

    private async Task CancelEdit()
    {
        if (Block == null) return;
        
        try
        {
            // Restaurer le contenu original
            UpdateBlockText(originalContent);
            UpdateBlockTitle(originalTitle);
            IsEditing = false;
            
            if (useRichEditor)
            {
                // Nettoyer l'éditeur
                await EditorService.DestroyEditorAsync(editorId);
                EditorInterop.UnsubscribeFromContentChanges(editorId);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de l'annulation des modifications: {ex.Message}");
        }
    }

    private async Task RequestDelete()
    {
        if (Block == null) return;
        
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Êtes-vous sûr de vouloir supprimer ce bloc?");
        if (confirmed)
        {
            await OnDeleteRequested.InvokeAsync(Block);
        }
    }
     
    private string GetTypeClass()
    {
        var classList = new List<string>();
        
        if (IsEditing)
        {
            classList.Add("editing");
        }
        
        if (string.IsNullOrEmpty(GetBlockText()))
        {
            classList.Add("empty");
        }
        
        return string.Join(" ", classList);
    }

    // Méthodes helper pour accéder aux propriétés de Block de façon sécurisée
    private string GetBlockText()
    {
        try
        {
            return Block?.Text?.ToString() ?? string.Empty;
        }
        catch
        {
            return string.Empty;
        }
    }

    private string GetBlockTitle()
    {
        try
        {
            return Block?.Title?.ToString() ?? string.Empty;
        }
        catch
        {
            return string.Empty;
        }
    }

    // Méthodes helper pour mettre à jour les propriétés de Block de façon sécurisée
    private void UpdateBlockText(string value)
    {
        try
        {
            Block.Text = value;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de la mise à jour du texte: {ex.Message}");
        }
    }

    private void UpdateBlockTitle(string value)
    {
        try
        {
            Block.Title = value;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de la mise à jour du titre: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            // Nettoyer les ressources lors de la suppression du composant
            if (Block != null && useRichEditor)
            {
                await EditorService.DestroyEditorAsync(editorId);
                EditorInterop.UnsubscribeFromContentChanges(editorId);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de la libération des ressources: {ex.Message}");
        }
    }
}