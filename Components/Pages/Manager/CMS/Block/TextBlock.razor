@page "/manager/cms/block/text/{blockId:int}"
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.EntityFrameworkCore
@using Microsoft.EntityFrameworkCore.Internal
@using Microsoft.JSInterop
@using Mooc.Data
@using Mooc.Services
@using static Mooc.Components.Pages.Manager.CMS.CourBuilder
@inject IJSRuntime JSRuntime
@using Mooc.Components.Shared
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory

@using System.ComponentModel.DataAnnotations
@using System.Text.Json

<EditForm Model="TypedContent" OnValidSubmit="HandleValidSubmit">
    <DataAnnotationsValidator />
    <ValidationSummary />

    <div class="text-block @GetTypeClass()" id="block-@Block.Order">
        <h4 class="text-title @(string.IsNullOrEmpty(TypedContent.Title) ? "text-muted" : "")">
            @if (IsEditing)
            {
                <InputText class="form-control" @bind-Value="TypedContent.Title" placeholder="Titre (optionnel)" />
            }
            else if (!string.IsNullOrEmpty(TypedContent.Title))
            {
                @TypedContent.Title
            }
        </h4>

        <div class="text-content">
            @if (IsEditing)
            {
                @if (useRichEditor)
                {
                    <RichEditor @ref="richEditorRef"
                    Value="@TypedContent.Text" 
                    ValueChanged="@OnTextContentChanged" 
                    Height="@EditorHeight"
                    Placeholder="Saisissez le contenu de votre bloc..." 
                    MaxLength="10000" 
                    EditorId="@editorId"
                    ShowCharacterCount="true" 
                    ShowToolbar="true"
                    />
                }
                else
                {
                    <InputTextArea class="form-control" @bind-Value="TypedContent.Text" rows="5" />
                }
            }
            else
            {
                <div class="text-message">
                    @if (!string.IsNullOrEmpty(TypedContent.Text))
                    {
                        @((MarkupString)SanitizeHtmlContent(TypedContent.Text))
                    }
                    else
                    {
                        <em class="text-muted">Aucun contenu</em>
                    }
                </div>
            }
        </div>

        <div class="block-controls mt-2">
            <button type="button" class="btn-block btn-valid"
                    @onclick="ToggleEdit" disabled="@(IsEditing && !IsValid())"
                    aria-label="@(IsEditing ? "Enregistrer les modifications" : "Modifier le bloc")">
                <i class="bi bi-@(IsEditing ? "floppy" : "pencil")"></i>
                @(IsEditing ? "Enregistrer" : "Modifier")
            </button>
            
            @if (IsEditing)
            {
                <button type="button" class="btn-block btn-cancel" @onclick="CancelEdit"
                        aria-label="Annuler les modifications">
                    <i class="bi bi-x-lg"></i> Annuler
                </button>
            }
            else
            {
                <button type="button" class="btn-block btn-cancel" @onclick="RequestDelete"
                        title="Supprimer ce bloc">
                    <i class="bi bi-trash"> Supprimer</i>
                </button>
            }
        </div>

        <!-- Indicateur de sauvegarde -->
        @if (isSaving)
        {
            <div class="save-indicator">
                <span class="spinner-border spinner-border-sm text-primary" role="status"></span>
                <span class="ms-1">Sauvegarde en cours...</span>
            </div>
        }

        <!-- Message de succès temporaire -->
        @if (showSaveSuccess)
        {
            <div class="alert alert-success mt-2 p-2 fade-out">
                Modifications enregistrées avec succès
            </div>
        }

        <!-- Message d'erreur -->
        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <div class="alert alert-danger mt-2 p-2">
                @errorMessage
            </div>
        }
    </div>
</EditForm>

@code {
    [Parameter]
    public int BlockId { get; set; }

    [Parameter]
    public dynamic Block { get; set; }

    [Parameter]
    public int CoursId { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnBlockChanged { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnDeleteRequested { get; set; }

    [Parameter]
    public bool IsEditing { get; set; } = false;

    [Parameter]
    public EventCallback<bool> OnEditStateChanged { get; set; }

    private bool useRichEditor { get; set; } = true;
    private bool titleError { get; set; } = false;
    private string editorId => Block != null ? $"editor-{Block.Order}" : "editor-temp";
    private bool isSaving { get; set; } = false;
    private bool showSaveSuccess { get; set; } = false;
    private bool editorInitialized { get; set; } = false;
    private RichEditor? richEditorRef;

    [Parameter]
    public int EditorHeight { get; set; } = 300;

    private Timer? autoSaveTimer;
    private bool hasUnsavedChanges = false;

    private string? errorMessage;
    private bool hasValidationErrors => !string.IsNullOrEmpty(errorMessage) || titleError;

    private TextBlockContent? _originalContent;

    private TextBlockContent TypedContent => Block.Content as TextBlockContent ?? new TextBlockContent();

    protected override void OnInitialized()
    {
        base.OnInitialized();
        EnsureContentInitialized();
        
        if (Block == null)
        {
            var newBlock = new CoursBlock
            {
                Type = "texte",
                Title = string.Empty,
                Order = 0
            };
            Block = newBlock;
        }

        Console.WriteLine($"TextBlock OnInitialized - CoursId: {CoursId}, Block.Id: {Block?.Id}");
    }

    protected override void OnParametersSet()
    {
        EnsureContentInitialized();
        Console.WriteLine($"TextBlock OnParametersSet - CoursId: {CoursId}, Block.Id: {Block?.Id}");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender && richEditorRef != null && !IsEditing)
        {
            // Appeler la fonction JavaScript pour améliorer l'affichage des images après le rendu
            try
            {
                await JSRuntime.InvokeVoidAsync("enhanceImageDisplay");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur lors de l'amélioration de l'affichage des images: {ex.Message}");
            }
        }
    }

    private void EnsureContentInitialized()
    {
        if (Block?.Content is not TextBlockContent)
        {
            Block.Content = new TextBlockContent
            {
                Title = Block?.Title ?? string.Empty,
                Text = Block?.Text ?? string.Empty
            };
        }
    }

    private string SanitizeHtmlContent(string htmlContent)
    {
        if (string.IsNullOrEmpty(htmlContent))
            return string.Empty;
            
        // Nettoyer le contenu des placeholders résiduels SANS toucher aux images
        var cleaned = htmlContent
            .Replace("<div style=\"color: #6c757d; font-style: italic;\">Commencez à écrire...</div>", "")
            .Replace("<div style=\"color: #6c757d; font-style: italic;\">Saisissez le contenu de votre bloc...</div>", "");
            
        // Log pour debug - vérifier si des images sont présentes après nettoyage
        if (cleaned.Contains("<img"))
        {
            Console.WriteLine("✅ Images préservées dans le contenu après nettoyage");
        }
            
        return cleaned.Trim();
    }

    private async Task OnTextContentChanged(string newContent)
    {
        // Log pour debug
        if (newContent.Contains("<img"))
        {
            Console.WriteLine($"📷 Image détectée dans le contenu: {newContent.Substring(0, Math.Min(100, newContent.Length))}...");
        }
        
        // CORRECTION: Ne pas nettoyer le contenu qui contient des images
        // Garder le contenu original avec les images
        string contentToSave = newContent;
        
        // Nettoyer seulement les placeholders s'il n'y a pas d'images
        if (!newContent.Contains("<img"))
        {
            contentToSave = SanitizeHtmlContent(newContent);
        }
        else
        {
            // Pour les contenus avec images, nettoyer seulement les placeholders spécifiques
            contentToSave = newContent
                .Replace("<div style=\"color: #6c757d; font-style: italic;\">Commencez à écrire...</div>", "")
                .Replace("<div style=\"color: #6c757d; font-style: italic;\">Saisissez le contenu de votre bloc...</div>", "");
        }
        
        TypedContent.Text = contentToSave;
        hasUnsavedChanges = true;
        StateHasChanged();
    }

    private bool IsValid()
    {
        // Considérer le contenu comme valide s'il y a du texte OU des images
        return !string.IsNullOrWhiteSpace(TypedContent.Text) || TypedContent.Text.Contains("<img");
    }

    private async Task ToggleEdit()
    {
        if (IsEditing)
        {
            if (!IsValid())
                return;

            try
            {
                isSaving = true;
                StateHasChanged();

                // Log du contenu avant sauvegarde
                Console.WriteLine($"💾 Sauvegarde du contenu: {TypedContent.Text.Substring(0, Math.Min(100, TypedContent.Text.Length))}...");
                if (TypedContent.Text.Contains("<img"))
                {
                    Console.WriteLine("✅ Image confirmée dans le contenu à sauvegarder");
                }

                Block.Title = TypedContent.Title;
                Block.Text = TypedContent.Text;

                // S'assurer que le contenu HTML est dans Content pour la sérialisation JSON
                if (Block.Content is TextBlockContent content)
                {
                    content.Text = TypedContent.Text;
                    content.Title = TypedContent.Title;
                }

                if (CoursId > 0)
                {
                    Console.WriteLine($"TextBlock: Sauvegarde pour CoursId: {CoursId}");

                    var blockService = new Mooc.Services.BlockService(DbContextFactory);
                    bool success = await blockService.SaveBlockAsync(Block, CoursId);

                    if (!success)
                    {
                        Console.WriteLine("❌ Erreur lors de la sauvegarde");
                        return;
                    }

                    // Vérifier immédiatement après la sauvegarde
                    await VerifyImageSave();
                }

                _originalContent = null;
                IsEditing = false;

                await OnBlockChanged.InvokeAsync(Block);

                showSaveSuccess = true;
                StateHasChanged();

                // Forcer l'amélioration de l'affichage des images après la sauvegarde
                await Task.Delay(100);
                try
                {
                    await JSRuntime.InvokeVoidAsync("enhanceImageDisplay");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Erreur lors de l'amélioration de l'affichage: {ex.Message}");
                }

                await Task.Delay(2000);
                showSaveSuccess = false;
            }
            catch (Exception ex)
            {
                errorMessage = "Erreur lors de la sauvegarde. Veuillez réessayer.";
                Console.WriteLine($"Erreur lors de la sauvegarde: {ex.Message}");
            }
            finally
            {
                isSaving = false;
                StateHasChanged();
            }
        }
        else
        {
            _originalContent = new TextBlockContent
            {
                Title = TypedContent.Title,
                Text = TypedContent.Text
            };
            
            IsEditing = true;
            await OnEditStateChanged.InvokeAsync(IsEditing);
            StateHasChanged();
        }
    }

    // Nouvelle méthode pour vérifier la sauvegarde des images
    private async Task VerifyImageSave()
    {
        try
        {
            await Task.Delay(500);
            
            using var context = await DbContextFactory.CreateDbContextAsync();
            var cours = await context.Courses.FindAsync(CoursId);
            
            if (cours != null && !string.IsNullOrEmpty(cours.Content))
            {
                var blocksFromDb = JsonSerializer.Deserialize<List<CourBuilder.CoursBlock>>(cours.Content) ?? new List<CourBuilder.CoursBlock>();
                var savedBlock = blocksFromDb.FirstOrDefault(b => b.Id == Block.Id);
                
                if (savedBlock != null)
                {
                    var savedText = savedBlock.Text ?? "";
                    // Vérifier les URLs d'images au lieu du base64
                    if (savedText.Contains("/uploads/images/"))
                    {
                        Console.WriteLine("✅ SUCCÈS: URL d'image sauvegardée en base de données");
                      }
                      else if (savedText.Contains("<img"))
                      {
                        Console.WriteLine("⚠️ Image trouvée mais format non optimal");
                      }
                      else
                      {
                        Console.WriteLine("❌ Aucune image dans le contenu sauvegardé");
                      }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Erreur lors de la vérification: {ex.Message}");
        }
    }

    // Améliorer la méthode CancelEdit pour préserver les images
    private async Task CancelEdit()
    {
        try
        {
            if (_originalContent != null)
            {
                // Rétablir le contenu original avec les images
                Block.Content = _originalContent;
                Block.Title = _originalContent.Title;
                Block.Text = _originalContent.Text;
                
                // Log pour debug
                if (_originalContent.Text.Contains("<img"))
                {
                    Console.WriteLine("🔄 Restauration du contenu avec images");
                }
                
                _originalContent = null;
            }
        
            IsEditing = false;
            hasUnsavedChanges = false;
            errorMessage = null;
            titleError = false;
        
            StateHasChanged();
            await Task.Delay(100);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de l'annulation: {ex.Message}");
            errorMessage = "Erreur lors de l'annulation des modifications";
        }
    }

    private async Task RequestDelete()
    {
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Êtes-vous sûr de vouloir supprimer ce bloc de texte ?");
        if (confirmed)
        {
            if (CoursId > 0)
            {
                Console.WriteLine($"TextBlock: Suppression pour CoursId: {CoursId}");
            }

            await OnDeleteRequested.InvokeAsync(Block);
        }
    }
     
    private string GetTypeClass() =>
        $"{(IsEditing ? "editing" : "")} {(string.IsNullOrEmpty(TypedContent.Text) ? "empty" : "")}".Trim();

    public class TextBlockContent
    {
        [MaxLength(100, ErrorMessage = "Le titre ne peut pas dépasser 100 caractères")]
        public string Title { get; set; } = string.Empty;

        [Required(ErrorMessage = "Le contenu ne peut pas être vide")]
        [MaxLength(10000, ErrorMessage = "Le contenu ne peut pas dépasser 10 000 caractères")]
        public string Text { get; set; } = string.Empty;
    }

    private async Task HandleValidSubmit()
    {
        await ToggleEdit();
    }
}