@page "/manager/cms/block/text/{blockId:int}"
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.EntityFrameworkCore
@using Microsoft.JSInterop
@using Mooc.Data
@using Mooc.Services
@using static Mooc.Components.Pages.Manager.CMS.CourBuilder
@inject IJSRuntime JSRuntime
@using Mooc.Components.Shared
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@implements IAsyncDisposable
@inject IContentValidationService ContentValidationService


@using System.ComponentModel.DataAnnotations
@using System.Text.Json

<EditForm Model="TypedContent" OnValidSubmit="HandleValidSubmit">
    <DataAnnotationsValidator />
    <ValidationSummary />

    <div class="text-block @GetTypeClass()" id="block-@Block.Order">
        <h4 class="text-title @(string.IsNullOrEmpty(TypedContent.Title) ? "text-muted" : "")">
            @if (IsEditing)
            {
                <InputText class="form-control" @bind-Value="TypedContent.Title" placeholder="Titre (optionnel)" />
            }
            else if (!string.IsNullOrEmpty(TypedContent.Title))
            {
                @TypedContent.Title
            }
        </h4>

        <div class="text-content">
            @if (IsEditing)
            {
                @if (useRichEditor)
                {
                    <RichEditor @ref="richEditorRef"
                        Value="@currentEditorContent" 
                        ValueChanged="@OnTextContentChanged" 
                        Height="@EditorHeight"
                        Placeholder="Saisissez le contenu de votre bloc..." 
                        MaxLength="10000" 
                        EditorId="@($"editor-block-{Block.Id}")"
                        ShowCharacterCount="true" 
                        ShowToolbar="true"
                        @key="@($"editor-{Block.Id}")"
                    />
                }
                else
                {
                    <InputTextArea class="form-control" @bind-Value="TypedContent.Text" rows="5" />
                }
            }
            else
            {
                <div class="text-message">
                    @if (!string.IsNullOrEmpty(TypedContent.Text))
                    {
                        @((MarkupString)SanitizeHtmlContent(TypedContent.Text))
                    }
                    else
                    {
                        <em class="text-muted">Aucun contenu</em>
                    }
                </div>
            }
        </div>

        <div class="block-controls mt-2">
            <button type="button" class="btn btn-valid m-2"
                    @onclick="ToggleEdit" 
                    @onclick:preventDefault="true"
                    disabled="@(IsEditing && !IsValid())"
                    aria-label="@(IsEditing ? "Enregistrer les modifications" : "Modifier le bloc")">
                <i class="bi bi-@(IsEditing ? "floppy" : "pencil")"></i>
                @(IsEditing ? "Enregistrer" : "Modifier")
            </button>
            
            @if (IsEditing)
            {
                <button type="button" class="btn btn-cancel"
                        @onclick="CancelEdit"
                        @onclick:preventDefault="true"
                        aria-label="Annuler les modifications">
                    <i class="bi bi-x-lg"></i> Annuler
                </button>
            }
            else
            {
                <button type="button" class="btn btn-cancel"
                        @onclick="RequestDelete"
                        @onclick:preventDefault="true"
                        title="Supprimer ce bloc">
                    <i class="bi bi-trash"> Supprimer</i>
                </button>
            }
        </div>

        <!-- Indicateurs d'état -->
        @if (isSaving)
        {
            <div class="save-indicator">
                <span class="spinner-border spinner-border-sm text-primary" role="status"></span>
                <span class="ms-1">Sauvegarde en cours...</span>
            </div>
        }

        @if (showSaveSuccess)
        {
            <div class="alert alert-success mt-2 p-2 fade-out">
                <i class="bi bi-check-circle-fill"></i>
                Modifications enregistrées avec succès
            </div>
        }

        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <div class="alert alert-danger mt-2 p-2" role="alert">
                <i class="bi bi-exclamation-triangle-fill"></i>
                @errorMessage
                <button type="button" class="btn-close btn-close-sm ms-2" @onclick="ClearError" aria-label="Fermer"></button>
            </div>
        }
    </div>
</EditForm>

@code {
    // === Paramètres ===
    [Parameter] public int BlockId { get; set; }
    [Parameter] public dynamic Block { get; set; }
    [Parameter] public int CoursId { get; set; }
    [Parameter] public EventCallback<CourBuilder.CoursBlock> OnBlockChanged { get; set; }
    [Parameter] public EventCallback<CourBuilder.CoursBlock> OnDeleteRequested { get; set; }
    [Parameter] public bool IsEditing { get; set; } = false;
    [Parameter] public EventCallback<bool> OnEditStateChanged { get; set; }
    [Parameter] public int EditorHeight { get; set; } = 300;

    // === État du composant ===
    private bool useRichEditor { get; set; } = true;
    private bool isSaving { get; set; } = false;
    private bool showSaveSuccess { get; set; } = false;
    private RichEditor? richEditorRef;
    private string? errorMessage;
    private TextBlockContent? _originalContent;
    private CancellationTokenSource? _autoSaveCts;
    private Timer? _successMessageTimer;

    // État local de l'éditeur
    private string currentEditorContent = string.Empty;
    private bool isInitialized = false;

    // === Propriétés calculées ===
    private string editorId => Block != null ? $"editor-{Block.Order}" : "editor-temp";
    private TextBlockContent TypedContent => Block.Content as TextBlockContent ?? new TextBlockContent();

    protected override void OnInitialized()
    {
        EnsureContentInitialized();
        InitializeBlock();
        currentEditorContent = TypedContent?.Text ?? string.Empty;
        isInitialized = true;
    }

    protected override void OnParametersSet()
    {
        // Éviter les re-rendus inutiles
        if (Block?.Content is not TextBlockContent)
        {
            EnsureContentInitialized();
        }

        // Mettre à jour le contenu de l'éditeur seulement si nécessaire
        if (isInitialized && !IsEditing)
        {
            currentEditorContent = TypedContent?.Text ?? string.Empty;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender && !IsEditing && (TypedContent.Text.Contains("<img") || HasVideoContent(TypedContent.Text)))
        {
            await EnhanceMediaDisplay();
        }

        // Initialiser l'éditeur seulement au premier rendu en mode édition
        if (firstRender && IsEditing && useRichEditor && richEditorRef != null)
        {
            try
            {
                await Task.Delay(200); // Délai pour s'assurer que l'éditeur est prêt
                await richEditorRef.SetContent(currentEditorContent);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur initialisation éditeur: {ex.Message}");
            }
        }
    }

    private void InitializeBlock()
    {
        if (Block == null)
        {
            Block = new CoursBlock
            {
                Type = "texte",
                Title = string.Empty,
                Order = 0
            };
        }
    }

    private void EnsureContentInitialized()
    {
        if (Block?.Content is not TextBlockContent)
        {
            Block.Content = new TextBlockContent
            {
                Title = Block?.Title ?? string.Empty,
                Text = Block?.Text ?? string.Empty
            };
        }
    }

    // ⚠️ CORRECTION : Vérifier la présence de contenu vidéo
    private bool HasVideoContent(string content)
    {
        if (string.IsNullOrEmpty(content))
            return false;
            
        return content.Contains("data-video-element") || 
               content.Contains("<iframe") || 
               content.Contains("<video") ||
               content.Contains("youtube.com") ||
               content.Contains("vimeo.com") ||
               content.Contains("dailymotion.com");
    }

    private async Task EnhanceMediaDisplay()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("enhanceImageDisplay");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur amélioration médias: {ex.Message}");
        }
    }

    private string SanitizeHtmlContent(string htmlContent)
    {
        if (string.IsNullOrEmpty(htmlContent))
            return string.Empty;
            
        // Utiliser le niveau "Standard" pour l'affichage en lecture seule
        return ContentValidationService.SanitizeHtmlContent(htmlContent, SanitizationLevel.Standard);
    }

    private async Task OnTextContentChanged(string newContent)
    {
        // Mettre à jour l'état local immédiatement
        currentEditorContent = newContent;
        
        // ⚠️ CORRECTION : Préserver TOUS les médias (images ET vidéos)
        var contentToSave = PreserveMediaContent(newContent);
        TypedContent.Text = contentToSave;
        
        // Debounce pour éviter trop d'appels
        _autoSaveCts?.Cancel();
        _autoSaveCts = new CancellationTokenSource();
        
        try
        {
            await Task.Delay(300, _autoSaveCts.Token);
            // Pas de StateHasChanged() ici pour éviter les re-rendus
        }
        catch (OperationCanceledException)
        {
            // Annulé, normal
        }
    }

    // ⚠️ CORRECTION : Méthode améliorée pour préserver TOUS les médias ET les couleurs
    private string PreserveMediaContent(string content)
    {
        if (string.IsNullOrEmpty(content))
            return string.Empty;

        // Nettoyer seulement les placeholders
        content = content
            .Replace("<div style=\"color: #6c757d; font-style: italic;\">Commencez à écrire...</div>", "")
            .Replace("<div style=\"color: #6c757d; font-style: italic;\">Saisissez le contenu de votre bloc...</div>", "")
            .Replace("<div class=\"placeholder-text\" style=\"color: #6c757d; font-style: italic; pointer-events: none;\">", "");

        // Vérifier si le contenu a des éléments riches ou des couleurs
        bool hasRichContent = content.Contains("<img") || 
                            content.Contains("data-video-element") || 
                            content.Contains("<iframe") || 
                            content.Contains("<video") ||
                            content.Contains("<audio") ||
                            content.Contains("<b>") ||
                            content.Contains("<i>") ||
                            content.Contains("<u>") ||
                            content.Contains("<strong>") ||
                            content.Contains("<em>") ||
                            content.Contains("<strike>") ||
                            content.Contains("<font") ||
                            content.Contains("youtube.com") ||
                            content.Contains("vimeo.com") ||
                            content.Contains("dailymotion.com") ||
                            // Vérifier la présence de couleurs
                            content.Contains("color:") ||
                            content.Contains("background-color:") ||
                            content.Contains("style=");

        if (hasRichContent)
        {
            // Utiliser le niveau "Minimal" pour préserver le formatage et les couleurs
            return ContentValidationService.SanitizeHtmlContent(content, SanitizationLevel.Minimal);
        }
        
        // Pour le texte simple, utiliser aussi la sanitisation minimale
        return ContentValidationService.SanitizeHtmlContent(content, SanitizationLevel.Minimal);
    }

    private bool IsValid()
    {
        var textContent = string.IsNullOrWhiteSpace(currentEditorContent) ? TypedContent.Text : currentEditorContent;
        
        return !string.IsNullOrWhiteSpace(textContent) || 
               textContent.Contains("<img") ||
               HasVideoContent(textContent) ||
               !string.IsNullOrWhiteSpace(TypedContent.Title);
    }

    private async Task ToggleEdit()
    {
        if (IsEditing)
        {
            await SaveChanges();
        }
        else
        {
            await StartEditing();
        }
    }

    private async Task StartEditing()
    {
        // Sauvegarder l'état original
        _originalContent = new TextBlockContent
        {
            Title = TypedContent.Title,
            Text = TypedContent.Text
        };
        
        // Initialiser le contenu de l'éditeur
        currentEditorContent = TypedContent.Text ?? string.Empty;
        
        IsEditing = true;
        await OnEditStateChanged.InvokeAsync(IsEditing);
        ClearError();

        // Forcer un re-rendu mais sans changer la clé
        StateHasChanged();

        // Initialiser l'éditeur après le re-rendu
        await Task.Delay(100);
        if (richEditorRef != null)
        {
            try
            {
                await richEditorRef.SetContent(currentEditorContent);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur initialisation contenu: {ex.Message}");
            }
        }
    }

    // Améliorer la méthode SaveChanges pour mieux préserver le contenu vidéo
    private async Task SaveChanges()
    {
        if (!IsValid())
        {
            errorMessage = "Le contenu ne peut pas être vide.";
            StateHasChanged();
            return;
        }

        try
        {
            isSaving = true;
            StateHasChanged();
            ClearError();

            // CORRECTION : Log du contenu avant traitement
            var rawContent = string.IsNullOrWhiteSpace(currentEditorContent) ? TypedContent.Text : currentEditorContent;
            Console.WriteLine($"Contenu brut avant traitement: {rawContent}");
            
            // Préserver le contenu média avec validation supplémentaire
            var finalContent = PreserveMediaContent(rawContent);
            Console.WriteLine($"Contenu après préservation: {finalContent}");
            
            // Vérifier que les vidéos sont toujours présentes
            bool hadVideoBefore = HasVideoContent(rawContent);
            bool hasVideoAfter = HasVideoContent(finalContent);
            
            if (hadVideoBefore && !hasVideoAfter)
            {
                Console.WriteLine("⚠️ ALERTE: Vidéo perdue pendant le traitement!");
                errorMessage = "Erreur: Le contenu vidéo a été perdu. Veuillez réessayer.";
                isSaving = false;
                StateHasChanged();
                return;
            }
            
            Block.Title = TypedContent.Title;
            Block.Text = finalContent;

            // Mise à jour du contenu sérialisable
            if (Block.Content is TextBlockContent content)
            {
                content.Text = finalContent;
                content.Title = TypedContent.Title;
            }

            if (CoursId > 0)
            {
                var blockService = new Mooc.Services.BlockService(DbContextFactory);
                bool success = await blockService.SaveBlockAsync(Block, CoursId);

                if (!success)
                {
                    errorMessage = "Erreur lors de la sauvegarde.";
                    isSaving = false;
                    StateHasChanged();
                    return;
                }

                await VerifyMediaSave();
            }

            _originalContent = null;
            IsEditing = false;

            await OnBlockChanged.InvokeAsync(Block);
            await OnEditStateChanged.InvokeAsync(IsEditing);
            await ShowSuccessMessage();
            
            // Améliorer l'affichage après sauvegarde
            await Task.Delay(100);
            await EnhanceMediaDisplay();
        }
        catch (Exception ex)
        {
            errorMessage = "Erreur lors de la sauvegarde. Veuillez réessayer.";
            Console.WriteLine($"Erreur sauvegarde: {ex.Message}");
        }
        finally
        {
            isSaving = false;
            StateHasChanged();
        }
    }

    private async Task ShowSuccessMessage()
    {
        showSaveSuccess = true;
        StateHasChanged();

        _successMessageTimer?.Dispose();
        _successMessageTimer = new Timer(_ => InvokeAsync(() =>
        {
            showSaveSuccess = false;
            StateHasChanged();
        }), null, TimeSpan.FromSeconds(3), Timeout.InfiniteTimeSpan);
    }

    private async Task CancelEdit()
    {
        try
        {
            if (_originalContent != null)
            {
                // Restaurer le contenu original
                Block.Content = _originalContent;
                Block.Title = _originalContent.Title;
                Block.Text = _originalContent.Text;
                currentEditorContent = _originalContent.Text;
                _originalContent = null;
            }

            IsEditing = false;
            ClearError();
            await OnEditStateChanged.InvokeAsync(IsEditing);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur annulation: {ex.Message}");
            errorMessage = "Erreur lors de l'annulation des modifications";
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task RequestDelete()
    {
        try
        {
            bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", 
                "Êtes-vous sûr de vouloir supprimer ce bloc de texte ?");
            
            if (confirmed)
            {
                await OnDeleteRequested.InvokeAsync(Block);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur suppression: {ex.Message}");
            errorMessage = "Erreur lors de la suppression";
        }
    }

    private void ClearError()
    {
        errorMessage = null;
    }

    // ⚠️ CORRECTION : Vérifier la sauvegarde de TOUS les médias
    private async Task VerifyMediaSave()
    {
        try
        {
            await Task.Delay(500);
            
            using var context = await DbContextFactory.CreateDbContextAsync();
            var cours = await context.Courses.FindAsync(CoursId);
            
            if (cours?.Content != null)
            {
                var blocksFromDb = JsonSerializer.Deserialize<List<CourBuilder.CoursBlock>>(cours.Content) ?? new();
                var savedBlock = blocksFromDb.FirstOrDefault(b => b.Id == Block.Id);
                
                if (savedBlock?.Text != null)
                {
                    bool hasImage = savedBlock.Text.Contains("/uploads/images/");
                    bool hasVideo = HasVideoContent(savedBlock.Text);
                    
                    if (hasImage)
                        Console.WriteLine("✅ Image sauvegardée avec succès");
                    if (hasVideo)
                        Console.WriteLine("✅ Vidéo sauvegardée avec succès");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur vérification: {ex.Message}");
        }
    }

    private string GetTypeClass() =>
        $"{(IsEditing ? "editing" : "")} {(string.IsNullOrEmpty(TypedContent.Text) ? "empty" : "")}".Trim();

    private async Task HandleValidSubmit()
    {
        await ToggleEdit();
    }

    public async ValueTask DisposeAsync()
    {
        _autoSaveCts?.Cancel();
        _autoSaveCts?.Dispose();
        _successMessageTimer?.Dispose();
    }

    public class TextBlockContent
    {
        [MaxLength(100, ErrorMessage = "Le titre ne peut pas dépasser 100 caractères")]
        public string Title { get; set; } = string.Empty;

        [Required(ErrorMessage = "Le contenu ne peut pas être vide")]
        [MaxLength(10000, ErrorMessage = "Le contenu ne peut pas dépasser 10 000 caractères")]
        public string Text { get; set; } = string.Empty;
    }
}