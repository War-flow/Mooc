@page "/manager/cms/block/text/{blockId:int}"
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using Mooc.Services
@using static Mooc.Components.Pages.Manager.CMS.CourBuilder
@inject IJSRuntime JSRuntime
@inject RichEditorService EditorService
@implements IAsyncDisposable

@if (Block != null)
{
    <div class="text-block @GetTypeClass()" id="block-@Block.Order">
        <h4 class="text-title @(string.IsNullOrEmpty(GetBlockTitle()) ? "text-muted" : "")">
            @if (IsEditing)
            {
                <input type="text" class="form-control" value="@GetBlockTitle()" @oninput="OnTitleChanged" placeholder="Titre (optionnel)"/>
                @if (titleError)
                {
                    <small class="text-danger">Le titre ne peut pas dépasser 100 caractères</small>
                }
            }
            else if (!string.IsNullOrEmpty(GetBlockTitle()))
            {
                @GetBlockTitle()
            }
        </h4>

        <div class="text-content">
            @if (IsEditing)
            {
                @if (useRichEditor)
                {
                    <div id="editor-@Block.Order" class="rich-editor" style="height:@(EditorHeight)px;"></div>
                }
                else
                {
                    <textarea class="form-control" value="@GetBlockText()" @oninput="OnTextChanged" rows="5"></textarea>
                }
            }
            else
            {
                <div class="text-message">
                    @if (useRichEditor)
                    {
                        @((MarkupString)GetBlockText())
                    }
                    else
                    {
                        @GetBlockText()
                    }
                </div>
            }
        </div>

        <div class="block-controls mt-2">
            <button type="button" class="btn-block btn-valid"
                    @onclick="ToggleEdit" disabled="@(IsEditing && !IsValid())"
                    aria-label="@(IsEditing ? "Enregistrer les modifications" : "Modifier le bloc")">
                <i class="bi bi-@(IsEditing ? "floppy" : "pencil")"></i>
                @(IsEditing ? "Enregistrer" : "Modifier")
            </button>
            
            @if (IsEditing)
            {
                <button type="button" class="btn-block btn-cancel" @onclick="CancelEdit"
                        aria-label="Annuler les modifications">
                    <i class="bi bi-x-lg"></i> Annuler
                </button>
            }
            else
            {
                <button type="button" class="btn-block btn-cancel" @onclick="RequestDelete"
                        title="Supprimer ce bloc">
                    <i class="bi bi-trash"> Supprimer</i>
                </button>
            }
        </div>

        <!-- Indicateur de sauvegarde -->
        @if (isSaving)
        {
            <div class="save-indicator">
                <span class="spinner-border spinner-border-sm text-primary" role="status"></span>
                <span class="ms-1">Sauvegarde en cours...</span>
            </div>
        }

        <!-- Message de succès temporaire -->
        @if (showSaveSuccess)
        {
            <div class="alert alert-success mt-2 p-2 fade-out">
                Modifications enregistrées avec succès
            </div>
        }

        <!-- Message d'erreur -->
        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <div class="alert alert-danger mt-2 p-2">
                @errorMessage
            </div>
        }
    </div>
}
else
{
    <div class="alert alert-warning">
        Chargement du bloc de texte en cours...
    </div>
}

@code {
    [Parameter]
    public int BlockId { get; set; }

    [Parameter]
    public dynamic Block { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnBlockChanged { get; set; }

    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnDeleteRequested { get; set; }

    [Parameter]
    public bool IsEditing { get; set; } = false;

    private bool useRichEditor { get; set; } = true;
    private bool titleError { get; set; } = false;
    private string editorId => Block != null ? $"editor-{Block.Order}" : "editor-temp";
    private bool isSaving { get; set; } = false;
    private bool showSaveSuccess { get; set; } = false;
    private bool editorInitialized { get; set; } = false;

    // Ajouter propriété pour la hauteur de l'éditeur
    [Parameter]
    public int EditorHeight { get; set; } = 200;

    private Timer? autoSaveTimer;
    private bool hasUnsavedChanges = false;

    // Ajouter des propriétés pour la validation
    private string? errorMessage;
    private bool hasValidationErrors => !string.IsNullOrEmpty(errorMessage) || titleError;

    // Contenu de sauvegarde pour annulation
    private TextBlockContent? _originalContent;

    // Propriété de commodité pour accéder au contenu typé
    private TextBlockContent TypedContent => Block.Content as TextBlockContent ?? new TextBlockContent();

    protected override void OnInitialized()
    {
        base.OnInitialized();
        
        EnsureContentInitialized();
        
        // S'assurer que Block n'est pas null
        if (Block == null)
        {
            // Créer un objet CoursBlock avec les propriétés minimales requises
            var newBlock = new CoursBlock
            {
                Type = "texte",
                Title = string.Empty,
                Order = 0
            };
            Block = newBlock;
        }
    }

    protected override void OnParametersSet()
    {
        EnsureContentInitialized();
    }

    private void EnsureContentInitialized()
    {
        if (Block?.Content is not TextBlockContent)
        {
            Block.Content = new TextBlockContent
            {
                Title = Block?.Title ?? string.Empty,
                Text = Block?.Text ?? string.Empty
            };
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (Block != null && useRichEditor && IsEditing && !editorInitialized)
        {
            await InitializeRichEditor();
        }
    }

    // Méthode améliorée pour initialiser l'éditeur
    private async Task InitializeRichEditor()
    {
        if (Block == null || !useRichEditor || editorInitialized) return;
        
        try
        {
            string content = TypedContent.Text;
            // Initialiser l'éditeur riche avec la hauteur configurable
            await EditorService.InitializeEditorAsync(editorId, content);
            
            // S'abonner aux changements de contenu
            EditorInterop.SubscribeToContentChanges(editorId, OnContentChanged);
            
            editorInitialized = true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de l'initialisation de l'éditeur: {ex.Message}");
        }
    }

    // Cette méthode sera appelée lorsque le contenu de l'éditeur change
    private void OnContentChanged(string elementId, string content)
    {
        if (Block != null)
        {
            TypedContent.Text = content;
            hasUnsavedChanges = true;
        }
    }

    // Méthode pour gérer le changement de texte dans le textarea
    private void OnTextChanged(ChangeEventArgs e)
    {
        if (Block != null && e.Value != null)
        {
            TypedContent.Text = e.Value.ToString() ?? string.Empty;
            hasUnsavedChanges = true;
        }
    }

    // Méthode pour gérer le changement de titre
    private void OnTitleChanged(ChangeEventArgs e)
    {
        if (Block != null && e.Value != null)
        {
            string value = e.Value.ToString() ?? string.Empty;
            
            if (value.Length > 100)
            {
                titleError = true;
                return;
            }
            
            titleError = false;
            TypedContent.Title = value;
            hasUnsavedChanges = true;
        }
    }

    // Méthode de validation similaire à InfoBlock
    private bool IsValid()
    {
        return !string.IsNullOrWhiteSpace(TypedContent.Text);
    }

    // Méthode de validation étendue
    private bool ValidateBlock()
    {
        errorMessage = null;
        titleError = false;

        if (TypedContent.Title.Length > 100)
        {
            titleError = true;
            errorMessage = "Le titre ne peut pas dépasser 100 caractères";
            return false;
        }

        if (string.IsNullOrWhiteSpace(TypedContent.Text))
        {
            errorMessage = "Le contenu ne peut pas être vide";
            return false;
        }

        if (TypedContent.Text.Length > 10000)
        {
            errorMessage = "Le contenu ne peut pas dépasser 10 000 caractères";
            return false;
        }

        return true;
    }

    // Nouvelle méthode ToggleEdit similaire à InfoBlock
    private async Task ToggleEdit()
    {
        if (IsEditing)
        {
            if (!IsValid())
                return;

            try
            {
                isSaving = true;
                StateHasChanged();

                // Récupérer le contenu de l'éditeur si nécessaire
                if (useRichEditor && editorInitialized)
                {
                    string editorContent = await EditorService.GetEditorContentAsync(editorId);
                    TypedContent.Text = editorContent;
                }

                // Synchroniser vers Block pour compatibilité
                Block.Title = TypedContent.Title;
                Block.Text = TypedContent.Text;
                
                _originalContent = null;
                IsEditing = false;
                
                await OnBlockChanged.InvokeAsync(Block);
                
                showSaveSuccess = true;
                StateHasChanged();
                
                await Task.Delay(2000);
                showSaveSuccess = false;
            }
            catch (Exception ex)
            {
                errorMessage = "Erreur lors de la sauvegarde. Veuillez réessayer.";
                Console.WriteLine($"Erreur lors de la sauvegarde: {ex.Message}");
            }
            finally
            {
                isSaving = false;
                StateHasChanged();
            }
        }
        else
        {
            // Créer un backup
            _originalContent = new TextBlockContent
            {
                Title = TypedContent.Title,
                Text = TypedContent.Text
            };
            
            IsEditing = true;
            
            // Initialiser l'éditeur après le rendu
            StateHasChanged();
        }
    }

    // Nouvelle méthode CancelEdit similaire à InfoBlock
    private async Task CancelEdit()
    {
        if (_originalContent != null)
        {
            Block.Content = _originalContent;
            Block.Title = _originalContent.Title;
            Block.Text = _originalContent.Text;
        }
        
        // Nettoyer l'éditeur riche si nécessaire
        if (useRichEditor && editorInitialized)
        {
            await EditorService.DestroyEditorAsync(editorId);
            editorInitialized = false;
        }
        
        IsEditing = false;
        hasUnsavedChanges = false;
    }

    // Méthode SaveChanges conservée pour la compatibilité
    private async Task SaveChanges()
    {
        await ToggleEdit();
    }

    private async Task RequestDelete()
    {
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Êtes-vous sûr de vouloir supprimer ce bloc de texte ?");
        if (confirmed)
        {
            await OnDeleteRequested.InvokeAsync(Block);
        }
    }
     
    private string GetTypeClass()
    {
        var classList = new List<string>();
        
        if (IsEditing)
        {
            classList.Add("editing");
        }
        
        if (string.IsNullOrEmpty(TypedContent.Text))
        {
            classList.Add("empty");
        }
        
        return string.Join(" ", classList);
    }

    // Méthodes helper pour accéder aux propriétés de Block de façon sécurisée
    private string GetBlockText()
    {
        return TypedContent.Text;
    }

    private string GetBlockTitle()
    {
        return TypedContent.Title;
    }

    public async ValueTask DisposeAsync()
    {
        autoSaveTimer?.Dispose();
        
        try
        {
            // Nettoyer les ressources lors de la suppression du composant
            if (Block != null && useRichEditor && editorInitialized)
            {
                await EditorService.DestroyEditorAsync(editorId);
                EditorInterop.UnsubscribeFromContentChanges(editorId);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur disposal: {ex.Message}");
        }
        
        _originalContent = null;
    }

    // Classe pour contenu spécifique à TextBlock
    public class TextBlockContent
    {
        public string Title { get; set; } = string.Empty;
        public string Text { get; set; } = string.Empty;
    }
}