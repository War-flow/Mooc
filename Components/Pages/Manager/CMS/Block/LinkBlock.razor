@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using System.Collections.Generic
@implements IDisposable

<div class="link-block @GetTypeClass()" @attributes="AdditionalAttributes">
    <h4 class="link-title">
        @if (IsEditing)
        {
            <InputText class="form-control" @bind-Value="Block.Title" placeholder="Titre (optionnel)" />
            <ValidationMessage For="@(() => Block.Title)" />
        }
        else if (!string.IsNullOrEmpty(Block.Title))
        {
            @Block.Title
        }
        else
        {
            <span class="text-muted">Bloc Liens (vide)</span>
        }
    </h4>
    <div class="link-content">
        @if (IsEditing)
        {
            <div class="mb-3">
                @foreach (var (url, index) in Links.Select((url, i) => (url, i)))
                {
                    <div class="d-flex mb-2">
                        <input type="text" class="form-control" value="@url" 
                               @oninput="@(e => UpdateLink(index, e.Value?.ToString() ?? string.Empty))" 
                               placeholder="URL du lien" />
                        <button type="button" class="btn btn-sm btn-danger ms-2" @onclick="@(() => RemoveLink(index))">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                    @if (!IsValidUrl(url) && !string.IsNullOrEmpty(url))
                    {
                        <small class="text-danger d-block mb-2">Veuillez saisir une URL valide (commence par http:// ou https://)</small>
                    }
                }
                <button type="button" class="btn btn-sm btn-success mt-2" @onclick="AddLink">
                    <i class="bi bi-plus-circle"></i> Ajouter un lien
                </button>
            </div>
        }
        else
        {
            <div class="links-display">
                @if (Links.Any())
                {
                    <ul class="list-group">
                        @foreach (var url in Links)
                        {
                            <li class="list-group-item">
                                <a href="@url" target="_blank" rel="noopener noreferrer" class="link-display">@url</a>
                            </li>
                        }
                    </ul>
                }
                else
                {
                    <div class="text-muted">Aucun lien ajouté</div>
                }
            </div>
        }
    </div>
    <div class="block-controls">
        <button type="button" class="btn-block btn-valid" @onclick="ToggleEdit">
            <i class="bi bi-@(IsEditing ? "floppy" : "pencil")"></i> @(IsEditing ? "Enregistrer" : "Modifier")
        </button>
        @if (IsEditing)
        {
            <button type="button" class="btn-block btn-cancel" @onclick="CancelEdit" title="Annuler les modifications">
                <i class="bi bi-x-octagon-fill"></i>Annuler
            </button>
        }
        else
        {
            <button type="button" class="btn-block btn-cancel" @onclick="RequestDelete" title="Supprimer ce bloc">
                <i class="bi bi-trash"></i>Supprimer
            </button>
        }
    </div>
</div>

@code {
    [Parameter]
    public CourBuilder.CoursBlock Block { get; set; } = default!;
    
    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnBlockChanged { get; set; }
    
    [Parameter]
    public EventCallback<CourBuilder.CoursBlock> OnDeleteRequested { get; set; }

    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    [Inject]
    private IJSRuntime JSRuntime { get; set; } = default!;

    private bool IsEditing { get; set; } = false;
    private List<string> Links { get; set; } = new();
    private List<string> OriginalLinks { get; set; } = new();
    private string originalTitle = string.Empty;

    protected override void OnInitialized()
    {
        // Initialiser les liens à partir du bloc existant
        DeserializeLinks();
    }

    private void DeserializeLinks()
    {
        Links.Clear();
        
        if (!string.IsNullOrEmpty(Block.Url))
        {
            // Si le Url contient plusieurs liens séparés par '|'
            if (Block.Url.Contains("|"))
            {
                Links.AddRange(Block.Url.Split('|', StringSplitOptions.RemoveEmptyEntries));
            }
            else
            {
                // Cas d'un seul lien
                Links.Add(Block.Url);
            }
        }
        
        // Assurez-vous qu'il y a au moins un champ vide si la liste est vide
        if (!Links.Any())
        {
            Links.Add(string.Empty);
        }
    }

    private void SerializeLinks()
    {
        // Filtrer les liens vides et joindre avec '|'
        Block.Url = string.Join("|", Links.Where(l => !string.IsNullOrWhiteSpace(l)));
    }

    private void AddLink()
    {
        Links.Add(string.Empty);
    }

    private void RemoveLink(int index)
    {
        if (index >= 0 && index < Links.Count)
        {
            Links.RemoveAt(index);
            
            // Assurez-vous qu'il y a au moins un champ vide
            if (!Links.Any())
            {
                Links.Add(string.Empty);
            }
        }
    }

    private void UpdateLink(int index, string value)
    {
        if (index >= 0 && index < Links.Count)
        {
            Links[index] = value;
        }
    }

    private async Task ToggleEdit()
    {
        if (IsEditing)
        {
            // Validation avant de sauvegarder
            bool isValid = true;
            foreach (var url in Links.Where(l => !string.IsNullOrWhiteSpace(l)))
            {
                if (!IsValidUrl(url))
                {
                    isValid = false;
                    break;
                }
            }

            if (!isValid)
            {
                await JSRuntime.InvokeVoidAsync("alert", "Certains liens ne sont pas valides. Veuillez corriger les erreurs.");
                return;
            }

            // Sérialiser les liens dans Block.Url
            SerializeLinks();
            
            // Notifier le parent que le bloc a changé
            await OnBlockChanged.InvokeAsync(Block);
            IsEditing = false;
        }
        else
        {
            // Sauvegarder l'état original pour permettre d'annuler
            OriginalLinks = new List<string>(Links);
            originalTitle = Block.Title ?? string.Empty;
            IsEditing = true;
        }
    }

    private void CancelEdit()
    {
        // Restaurer le contenu original
        Links = new List<string>(OriginalLinks);
        Block.Title = originalTitle;
        IsEditing = false;
    }

    private async Task RequestDelete()
    {
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Êtes-vous sûr de vouloir supprimer ce bloc?");
        if (confirmed)
        {
            await OnDeleteRequested.InvokeAsync(Block);
        }
    }

    private string GetTypeClass()
    {
        var classList = new List<string>();
        
        if (IsEditing)
        {
            classList.Add("editing");
        }
        
        if (!Links.Any(l => !string.IsNullOrWhiteSpace(l)))
        {
            classList.Add("empty");
        }
        
        return string.Join(" ", classList);
    }

    private bool IsValidUrl(string url)
    {
        return string.IsNullOrEmpty(url) || url.StartsWith("http://") || url.StartsWith("https://");
    }

    public void Dispose()
    {
        // Nettoyer les ressources si nécessaire
    }
}
