@page "/Cours/View/{CoursId:int}"
@page "/Cours/View/{CoursId:int}/Block/{BlockIndex:int}"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Authorization
@using Mooc.Data
@using Microsoft.EntityFrameworkCore
@using Mooc.Components.Pages.Manager.CMS
@using Mooc.Components.Pages.Manager.CMS.Block
@using Mooc.Components.Pages.Manager.CMS.Block.ReadOnly
@using Mooc.Services
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject NavigationManager NavigationManager
@inject CourseStateService CourseStateService
@inject IJSRuntime JSRuntime

<PageTitle>@(cours?.Title ?? "Cours") - @GetCurrentBlockTitle()</PageTitle>

<div class="container mt-4">
    @if (cours != null)
    {
        <div class="row">
            <div class="col-md-8">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h2 class="mb-0">@cours.Title</h2>
                        <div class="cours-progress">
                            @if (courseProgress != null)
                            {
                                <span class="badge bg-success ms-2">
                                    @courseProgress.CompletedBlocks.Count complété(s)
                                </span>
                                @if (courseProgress.IsCompleted)
                                {
                                    <span class="badge bg-success ms-2">
                                        <i class="bi bi-check-circle me-1"></i>
                                        Cours terminé
                                    </span>
                                }
                            }
                        </div>
                    </div>
                    <div class="card-body">
                        @if (!string.IsNullOrEmpty(cours.Description))
                        {
                            <p class="text-muted">@cours.Description</p>
                        }
                        <div class="mb-3">
                            <span class="badge bg-primary me-2">
                                <i class="bi bi-clock me-1"></i>
                                @cours.Duration min
                            </span>
                            @if (cours.IsRequired)
                            {
                                <span class="badge bg-warning">Obligatoire</span>
                            }
                        </div>

                        <!-- Barre de progression -->
                        @if (courseProgress != null && blocks != null)
                        {
                            var progressPercentage = blocks.Count > 0 ? (courseProgress.CompletedBlocks.Count * 100 / blocks.Count) : 0;
                            <div class="progress mb-3" style="height: 8px;">
                                <div class="progress-bar bg-success" role="progressbar"
                                     style="width: @progressPercentage%"
                                     aria-valuenow="@progressPercentage"
                                     aria-valuemin="0"
                                     aria-valuemax="100"></div>
                            </div>
                            <small class="text-muted">Progression: @progressPercentage%</small>
                        }
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">Navigation</h5>
                    </div>
                    <div class="card-body">
                        <hr />
                        <p><strong>Session :</strong> @cours.Session?.Title</p>
                        <p><strong>Date de début :</strong> @cours.Session?.StartDate.ToString("dd/MM/yyyy")</p>
                        <p><strong>Date de fin :</strong> @cours.Session?.EndDate.ToString("dd/MM/yyyy")</p>
                        <hr />
                    </div>
                </div>
            </div>
        </div>

        <div class="card mt-4">
            <div class="card-header d-flex justify-content-between align-items-center">
                <div class="block-navigation">
                    @if (CurrentBlockIndex < (blocks?.Count ?? 0) - 1)
                    {
                        <button class="btn btn-outline-primary btn-sm"
                                @onclick="() => GoToNextBlock()"
                                disabled="@(!CanNavigateToNext())">
                            Suivant <i class="bi bi-arrow-right"></i>
                        </button>

                        @if (!CanNavigateToNext() && IsCurrentBlockQuiz())
                        {
                            <small class="text-warning ms-2">
                                <i class="bi bi-exclamation-triangle me-1"></i>
                                Vous devez compléter ce quiz pour continuer
                            </small>
                        }
                    }
                    else if (IsLastBlock() && !IsCurrentBlockCompleted())
                    {
                        <!-- Bouton pour terminer le cours sur le dernier bloc -->
                        <button class="btn btn-success btn-sm"
                                @onclick="() => CompleteCourse()"
                                disabled="@(!CanCompleteCourse())">
                            <i class="bi bi-check-circle me-1"></i>
                            Terminer le cours
                        </button>

                        @if (!CanCompleteCourse() && IsCurrentBlockQuiz())
                        {
                            <small class="text-warning ms-2">
                                <i class="bi bi-exclamation-triangle me-1"></i>
                                Vous devez compléter ce quiz pour terminer le cours
                            </small>
                        }
                    }
                    else if (courseProgress?.IsCompleted == true)
                    {
                        <!-- Message de félicitations si le cours est terminé -->
                        <div class="alert alert-success mb-0">
                            <i class="bi bi-trophy me-2"></i>
                            <strong>Félicitations !</strong> Vous avez terminé ce cours avec succès.
                            <p class="mb-0 mt-2">
                                <i class="bi bi-check-circle me-1"></i>
                                Vous avez répondu correctement à <strong>@GetCorrectAnswersCount()</strong> quiz sur <strong>@GetTotalQuizCount()</strong>
                                @if (GetTotalQuizCount() > 0)
                                {
                                    <span class="ms-2 badge bg-info">
                                        @(Math.Round((double)GetCorrectAnswersCount() / GetTotalQuizCount() * 100, 1))%
                                    </span>
                                }
                            </p>
                        </div>
                    }
                </div>
            </div>
            <div class="card-body">
                @if (blocks != null && blocks.Any() && CurrentBlockIndex >= 0 && CurrentBlockIndex < blocks.Count)
                {
                    var currentBlock = blocks[CurrentBlockIndex];
                    <div class="cours-block-viewer">
                        <DynamicComponent Type="@GetViewerBlockComponent(currentBlock.Type)"
                                          Parameters="@GetViewerBlockParameters(currentBlock)" />
                    </div>

                }
                else
                {
                    <div class="alert alert-info">
                        <i class="bi bi-info-circle me-2"></i>
                        Ce cours ne contient pas encore de contenu.
                    </div>
                }
                <div class="card-footer d-flex justify-content-between align-items-center">
                    <div class="block-navigation">
                        @if (CurrentBlockIndex < (blocks?.Count ?? 0) - 1)
                        {
                            <button class="btn btn-outline-primary btn-sm"
                                    @onclick="() => GoToNextBlock()"
                                    disabled="@(!CanNavigateToNext())">
                                Suivant <i class="bi bi-arrow-right"></i>
                            </button>

                            @if (!CanNavigateToNext() && IsCurrentBlockQuiz())
                            {
                                <small class="text-warning ms-2">
                                    <i class="bi bi-exclamation-triangle me-1"></i>
                                    Vous devez compléter ce quiz pour continuer
                                </small>
                            }
                        }
                        else if (IsLastBlock() && !IsCurrentBlockCompleted())
                        {
                            <!-- Bouton pour terminer le cours sur le dernier bloc (footer aussi) -->
                            <button class="btn btn-success"
                                    @onclick="() => CompleteCourse()"
                                    disabled="@(!CanCompleteCourse())">
                                <i class="bi bi-check-circle me-1"></i>
                                Terminer le cours
                            </button>

                            @if (!CanCompleteCourse() && IsCurrentBlockQuiz())
                            {
                                <small class="text-warning ms-2">
                                    <i class="bi bi-exclamation-triangle me-1"></i>
                                    Vous devez compléter ce quiz pour terminer le cours
                                </small>
                            }
                        }
                        else if (courseProgress?.IsCompleted == true)
                        {
                            <!-- Bouton pour retourner à la liste des cours -->
                            <button class="btn btn-outline-secondary"
                                    @onclick="RetourVersListe">
                                <i class="bi bi-arrow-left me-1"></i>
                                Retour aux cours
                            </button>
                        }
                    </div>
                </div>
            </div>
        </div>
    }
    else if (isLoading)
    {
        <div class="text-center">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Chargement...</span>
            </div>
        </div>
    }
    else
    {
        <div class="alert alert-warning">
            <i class="bi bi-exclamation-triangle me-2"></i>
            Le cours demandé n'a pas été trouvé.
        </div>
    }
</div>


@code {
    [Parameter]
    public int CoursId { get; set; }

    [Parameter]
    public int? BlockIndex { get; set; }

    private Cours? cours;
    private List<CourBuilder.CoursBlock>? blocks;
    private bool isLoading = true;
    private int CurrentBlockIndex => BlockIndex ?? 0;
    private Services.CourseProgress? courseProgress;

    // Dictionnaire pour tracker l'état des quiz par bloc
    private Dictionary<int, bool> quizCompletionState = new();

    protected override async Task OnInitializedAsync()
    {
        await LoadCoursData();
        await LoadCourseProgress();
    }

    protected override async Task OnParametersSetAsync()
    {
        // Rediriger vers le bloc précédemment consulté ou le premier bloc
        if (!BlockIndex.HasValue && blocks != null && blocks.Any())
        {
            var targetBlock = courseProgress?.LastAccessedBlock ?? 0;
            NavigationManager.NavigateTo(GetBlockUrl(targetBlock), replace: true);
        }

        // Vérifier que l'index est valide
        if (BlockIndex.HasValue && blocks != null &&
            (BlockIndex.Value < 0 || BlockIndex.Value >= blocks.Count))
        {
            NavigationManager.NavigateTo(GetBlockUrl(0), replace: true);
        }

        // **NOUVEAU**: Bloquer l'accès aux blocs complétés
        if (BlockIndex.HasValue && courseProgress != null &&
            courseProgress.CompletedBlocks.Contains(BlockIndex.Value))
        {
            // Rediriger vers le dernier bloc accessible (non complété)
            var nextIncompleteBlock = GetNextIncompleteBlock();
            if (nextIncompleteBlock.HasValue)
            {
                NavigationManager.NavigateTo(GetBlockUrl(nextIncompleteBlock.Value), replace: true);
                return;
            }
            else
            {
                // Si tous les blocs sont complétés, rester sur le dernier bloc
                var lastBlock = (blocks?.Count ?? 1) - 1;
                if (BlockIndex.Value != lastBlock)
                {
                    NavigationManager.NavigateTo(GetBlockUrl(lastBlock), replace: true);
                    return;
                }
            }
        }

        // Sauvegarder l'accès au bloc actuel
        if (BlockIndex.HasValue && courseProgress != null)
        {
            courseProgress.LastAccessedBlock = BlockIndex.Value;
            await CourseStateService.SaveProgressAsync(courseProgress);
        }
    }

    // **NOUVELLE MÉTHODE**: Trouver le prochain bloc non complété
    private int? GetNextIncompleteBlock()
    {
        if (blocks == null || courseProgress == null) return null;

        for (int i = 0; i < blocks.Count; i++)
        {
            if (!courseProgress.CompletedBlocks.Contains(i))
            {
                return i;
            }
        }

        return null; // Tous les blocs sont complétés
    }

    private async Task LoadCoursData()
    {
        try
        {
            using var context = await DbContextFactory.CreateDbContextAsync();
            cours = await context.Courses
                .Include(c => c.Session)
                .FirstOrDefaultAsync(c => c.Id == CoursId);

            if (cours != null && !string.IsNullOrEmpty(cours.Content))
            {
                try
                {
                    blocks = System.Text.Json.JsonSerializer.Deserialize<List<CourBuilder.CoursBlock>>(
                        cours.Content,
                        new System.Text.Json.JsonSerializerOptions
                        {
                            PropertyNameCaseInsensitive = true
                        });
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Erreur lors de la désérialisation des blocs: {ex.Message}");
                    blocks = new List<CourBuilder.CoursBlock>();
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du chargement du cours: {ex.Message}");
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task LoadCourseProgress()
    {
        try
        {
            // Pour l'instant, utiliser un utilisateur anonyme
            // Dans une vraie application, récupérer l'ID de l'utilisateur connecté
            courseProgress = await CourseStateService.GetOrCreateProgressAsync(CoursId);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du chargement du progrès: {ex.Message}");
        }
    }

    private async Task MarkBlockAsCompleted()
    {
        if (courseProgress != null)
        {
            courseProgress.CompletedBlocks.Add(CurrentBlockIndex);

            // Vérifier si le cours est complété
            if (blocks != null && courseProgress.CompletedBlocks.Count >= blocks.Count)
            {
                courseProgress.IsCompleted = true;
                await JSRuntime.InvokeVoidAsync("alert", "Félicitations ! Vous avez terminé ce cours.");
            }

            await CourseStateService.SaveProgressAsync(courseProgress);
            StateHasChanged();
        }
    }

    // **NOUVELLE MÉTHODE**: Terminer le cours
    private async Task CompleteCourse()
    {
        if (courseProgress == null || blocks == null) return;

        try
        {
            // Marquer le dernier bloc comme complété
            if (!courseProgress.CompletedBlocks.Contains(CurrentBlockIndex))
            {
                courseProgress.CompletedBlocks.Add(CurrentBlockIndex);
            }

            // Marquer le cours comme terminé
            courseProgress.IsCompleted = true;

            // Sauvegarder les modifications
            await CourseStateService.SaveProgressAsync(courseProgress);

            // Afficher un message de félicitations détaillé
            var correctAnswers = GetCorrectAnswersCount();
            var totalQuiz = GetTotalQuizCount();
            var scoreMessage = totalQuiz > 0 ? $"\nScore: {correctAnswers}/{totalQuiz} quiz réussis ({Math.Round((double)correctAnswers / totalQuiz * 100, 1)}%)" : "";

            // Rafraîchir l'interface
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de la completion du cours: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("alert", "Une erreur s'est produite lors de la completion du cours.");
        }
    }

    // **NOUVELLES MÉTHODES UTILITAIRES**
    private bool IsLastBlock()
    {
        if (blocks == null) return false;
        return CurrentBlockIndex == blocks.Count - 1;
    }

    private bool IsCurrentBlockCompleted()
    {
        if (courseProgress == null) return false;
        return courseProgress.CompletedBlocks.Contains(CurrentBlockIndex);
    }

    private bool CanCompleteCourse()
    {
        if (blocks == null || courseProgress == null) return false;

        var currentBlock = blocks[CurrentBlockIndex];

        // Si ce n'est pas un quiz, permettre la completion
        if (currentBlock.Type != "quiz")
        {
            return true;
        }

        // Si c'est un quiz, vérifier s'il est complété
        return quizCompletionState.ContainsKey(CurrentBlockIndex) && quizCompletionState[CurrentBlockIndex];
    }

    private void RetourVersListe()
    {
        var sessionId = cours?.SessionId;

        if (sessionId.HasValue)
        {
            // Si on connaît la session, rediriger vers la gestion des cours de cette session
            NavigationManager.NavigateTo($"/session/{sessionId.Value}");
        }
        else
        {
            // Sinon, rediriger vers la liste générale des cours
            NavigationManager.NavigateTo("/Manager/Cours");
        }
    }

    private string GetBlockUrl(int blockIndex)
    {
        return $"/Cours/View/{CoursId}/Block/{blockIndex}";
    }

    private string GetCurrentBlockTitle()
    {
        if (blocks == null || !blocks.Any() || CurrentBlockIndex < 0 || CurrentBlockIndex >= blocks.Count)
            return "Contenu du cours";

        var currentBlock = blocks[CurrentBlockIndex];
        return !string.IsNullOrEmpty(currentBlock.Title)
            ? currentBlock.Title
            : $"Bloc {CurrentBlockIndex + 1}";
    }

    private string GetBlockTypeDisplay(string type) => type switch
    {
        "texte" => "Texte",
        "quiz" => "Quiz",
        _ => "Contenu"
    };

    // Méthode pour obtenir le composant viewer correspondant à chaque type de bloc
    private Type GetViewerBlockComponent(string type) => type switch
    {
        "texte" => typeof(TextBlockViewer),
        "quiz" => typeof(QuizBlockViewer),
        _ => typeof(TextBlockViewer)
    };

    // Méthode pour créer les paramètres pour les composants viewer
    private Dictionary<string, object> GetViewerBlockParameters(CourBuilder.CoursBlock block)
    {
        var parameters = new Dictionary<string, object>
        {
            ["Block"] = block,
            ["IsReadOnly"] = true
        };

        // Ajouter le callback pour les quiz
        if (block.Type == "quiz")
        {
            parameters["OnQuizCompleted"] = EventCallback.Factory.Create<bool>(this, OnQuizCompleted);
        }

        return parameters;
    }

    private async Task GoToNextBlock()
    {
        // Vérifier si la navigation est autorisée
        if (!CanNavigateToNext())
        {
            if (IsCurrentBlockQuiz())
            {
                await JSRuntime.InvokeVoidAsync("alert", "Vous devez compléter ce quiz pour continuer vers le bloc suivant.");
            }
            return;
        }

        // Marquer le bloc actuel comme complété s'il ne l'est pas déjà
        if (courseProgress != null && !courseProgress.CompletedBlocks.Contains(CurrentBlockIndex))
        {
            await MarkBlockAsCompleted();
        }

        // Naviguer vers le bloc suivant
        if (CurrentBlockIndex < (blocks?.Count ?? 0) - 1)
        {
            NavigationManager.NavigateTo(GetBlockUrl(CurrentBlockIndex + 1));
        }
    }

    // **NOUVELLES MÉTHODES** : Gestion de l'état des quiz
    private bool CanNavigateToNext()
    {
        if (blocks == null) return false;

        var currentBlock = blocks[CurrentBlockIndex];

        // Si ce n'est pas un quiz, permettre la navigation
        if (currentBlock.Type != "quiz")
        {
            return true;
        }

        // Si c'est un quiz, vérifier s'il est complété
        return quizCompletionState.ContainsKey(CurrentBlockIndex) && quizCompletionState[CurrentBlockIndex];
    }

    private bool IsCurrentBlockQuiz()
    {
        if (blocks == null) return false;
        return blocks[CurrentBlockIndex].Type == "quiz";
    }

    private async Task OnQuizCompleted(bool isCorrect)
    {
        // Marquer le quiz comme complété (peu importe si correct ou incorrect)
        quizCompletionState[CurrentBlockIndex] = true;

        // Enregistrer la réponse dans les interactions
        if (courseProgress != null)
        {
            // Sauvegarder l'interaction du quiz
            var quizInteraction = new { completed = true, correct = isCorrect, timestamp = DateTime.UtcNow };
            courseProgress.BlockInteractions[CurrentBlockIndex] = System.Text.Json.JsonSerializer.Serialize(quizInteraction);

            // **CORRECTION** : Ne plus incrémenter manuellement CorrectAnswers
            // Le comptage sera fait automatiquement par CalculateCorrectAnswersFromInteractions dans CourseStateService
            
            await CourseStateService.SaveProgressAsync(courseProgress);
        }

        // Rafraîchir l'interface
        StateHasChanged();
    }

    // **NOUVELLE MÉTHODE CORRIGÉE**: Calcul des statistiques de quiz basé sur les interactions
    private int GetCorrectAnswersCount()
    {
        if (courseProgress?.BlockInteractions == null) return 0;
        
        int correctCount = 0;
        foreach (var interaction in courseProgress.BlockInteractions)
        {
            try
            {
                using var document = System.Text.Json.JsonDocument.Parse(interaction.Value);
                if (document.RootElement.TryGetProperty("correct", out var correctProperty) &&
                    correctProperty.GetBoolean())
                {
                    correctCount++;
                }
            }
            catch
            {
                // Ignorer les interactions mal formées
            }
        }
        
        return correctCount;
    }

    // **NOUVELLES MÉTHODES**: Calcul des statistiques de quiz
    private int GetTotalQuizCount()
    {
        if (blocks == null) return 0;
        return blocks.Count(b => b.Type == "quiz");
    }

    // Ajoutez cette méthode pour vérifier si un bloc est accessible
    private bool IsBlockAccessible(int blockIndex)
    {
        if (courseProgress == null) return true;

        // Un bloc est accessible s'il n'est pas complété
        return !courseProgress.CompletedBlocks.Contains(blockIndex);
    }
}