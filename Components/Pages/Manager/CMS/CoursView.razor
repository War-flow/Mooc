@page "/cours/view/{CoursId:int}"
@page "/cours/view/{CoursId:int}/block/{BlockIndex:int}"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Authorization
@using Mooc.Data
@using Microsoft.EntityFrameworkCore
@using Mooc.Components.Pages.Manager.CMS
@using Mooc.Components.Pages.Manager.CMS.Block
@using Mooc.Components.Pages.Manager.CMS.Block.ReadOnly
@using Mooc.Services
@implements IAsyncDisposable
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject NavigationManager NavigationManager
@inject CourseStateService CourseStateService
@inject IJSRuntime JSRuntime

<PageTitle>@(cours?.Title ?? "Cours") - @GetCurrentBlockTitle()</PageTitle>

@if (isLoading)
{
    <div class="d-flex justify-content-center align-items-center" style="min-height: 60vh;">
        <div class="text-center">
            <div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem;">
                <span class="visually-hidden">Chargement...</span>
            </div>
            <p class="mt-3 text-muted">Chargement du cours...</p>
        </div>
    </div>
}
else if (cours == null)
{
    <div class="container mt-4">
        <div class="alert alert-warning d-flex align-items-center">
            <i class="bi bi-exclamation-triangle me-3 fs-4"></i>
            <div>
                <strong>Cours introuvable</strong>
                <p class="mb-0">Le cours demandé n'a pas été trouvé ou n'est plus disponible.</p>
            </div>
        </div>
        <button class="btn btn-primary" @onclick='() => NavigationManager.NavigateTo("/Manager/Cours")'>
            <i class="bi bi-arrow-left me-1"></i> Retour aux cours
        </button>
    </div>
}
else 
{
    <div class="container mt-4">
        <!-- En-tête du cours amélioré -->
        <div class="row mb-4">
            <div class="col-md-8">
                <div class="card shadow-sm">
                    <div class="card-header bg-primary text-white">
                        <div class="d-flex justify-content-between align-items-center">
                            <h2 class="m-1">
                                <i class="bi @(IsReadOnlyMode ? "bi-eye-fill" : "bi-book") me-2"></i>
                                @cours.Title
                            </h2>
                            <div class="course-status">
                                @if (IsReadOnlyMode)
                                {
                                    <span class="badge bg-info fs-6">
                                        <i class="bi bi-eye-fill me-1"></i>
                                        Mode consultation
                                    </span>
                                }
                                else if (courseProgress?.IsCompleted == true)
                                {
                                    <span class="badge bg-success fs-6">
                                        <i class="bi bi-trophy-fill me-1"></i>
                                        Terminé
                                    </span>
                                }
                                else if (courseProgress != null && courseProgress.CompletedBlocks.Any())
                                {
                                    <span class="badge bg-info fs-6">
                                        <i class="bi bi-clock-history me-1"></i>
                                        En cours
                                    </span>
                                }
                                else
                                {
                                    <span class="badge bg-secondary fs-6">
                                        <i class="bi bi-play me-1"></i>
                                        Non commencé
                                    </span>
                                }
                            </div>
                        </div>
                    </div>
                    <div class="card-body">
                        <!-- **NOUVEAU: Bandeau d'information en mode lecture seule** -->
                        @if (IsReadOnlyMode)
                        {
                            <div class="alert alert-info d-flex align-items-center mb-3">
                                <i class="bi bi-info-circle me-3 fs-4"></i>
                                <div>
                                    <strong>Mode consultation</strong>
                                    <p class="mb-0">Vous consultez ce cours que vous avez déjà terminé. Les quiz ne sont pas accessibles dans ce mode.</p>
                                </div>
                            </div>
                        }

                        @if (!string.IsNullOrEmpty(cours.Description))
                        {
                            <p class="text-muted mb-3">@cours.Description</p>
                        }

                        <!-- Barre de progression améliorée -->
                        @if (courseProgress != null && blocks != null)
                        {
                            var progressPercentage = blocks.Count > 0 ? (courseProgress.CompletedBlocks.Count * 100 / blocks.Count) : 0;
                            <div class="progress mb-3" style="height: 12px;">
                                <div class="progress-bar bg-gradient progress-bar-striped @(courseProgress.IsCompleted ? "bg-success" : "bg-info")"
                                     role="progressbar"
                                     style="width: @progressPercentage%"
                                     aria-valuenow="@progressPercentage"
                                     aria-valuemin="0"
                                     aria-valuemax="100">
                                </div>
                            </div>
                            <div class="d-flex justify-content-between align-items-center">
                                <small class="text-muted">
                                    <i class="bi bi-graph-up me-1"></i>
                                    Progression: @progressPercentage% (@courseProgress.CompletedBlocks.Count/@blocks.Count blocs)
                                </small>
                                @if (courseProgress.IsCompleted)
                                {
                                    <small class="text-success fw-bold">
                                        <i class="bi bi-check-circle-fill me-1"></i>
                                        Cours terminé !
                                    </small>
                                }
                            </div>
                        }

                        <!-- Navigation entre blocs -->
                        @if (blocks != null && blocks.Any())
                        {
                            <div class="block-navigation mt-3">
                                <div class="d-flex justify-content-between align-items-center">
                                    <button class="btn btn-outline-primary"
                                            @onclick="GoToPreviousBlock"
                                            disabled="@(CurrentBlockIndex <= 0 || (IsReadOnlyMode && IsBlockTypeQuiz(CurrentBlockIndex - 1)))">
                                        <i class="bi bi-arrow-left me-1"></i>
                                        Précédent
                                    </button>

                                    <div class="block-counter">
                                        <span class="badge bg-light text-dark">
                                            Bloc @(CurrentBlockIndex + 1) sur @blocks.Count
                                        </span>
                                    </div>

                                    <button class="btn btn-outline-primary"
                                            @onclick="GoToNextBlock"
                                            disabled="@(!CanNavigateToNext() || (IsReadOnlyMode && IsBlockTypeQuiz(CurrentBlockIndex + 1)))">
                                        Suivant
                                        <i class="bi bi-arrow-right ms-1"></i>
                                    </button>
                                </div>
                            </div>
                        }
                    </div>
                </div>
            </div>

            <div class="col-md-4">
                <div class="card shadow-sm">
                    <div class="card-header">
                        <h5 class="mb-0">
                            <i class="bi bi-info-circle me-2"></i>
                            Informations
                        </h5>
                    </div>
                    <div class="card-body">
                        <div class="info-item mb-3">
                            <strong>Session :</strong>
                            <p class="mb-0">@cours.Session?.Title</p>
                        </div>
                        <div class="info-item mb-3">
                            <strong>Période :</strong>
                            <p class="mb-0">
                                Du @cours.Session?.StartDate.ToString("dd/MM/yyyy")
                                au @cours.Session?.EndDate.ToString("dd/MM/yyyy")
                            </p>
                        </div>

                        <!-- Liste des blocs avec statut -->
                        @if (blocks != null && blocks.Any())
                        {
                            <div class="blocks-overview">
                                <strong>Contenu du cours :</strong>
                                <div class="list-group list-group-flush mt-2">
                                    @for (int i = 0; i < blocks.Count; i++)
                                    {
                                        var blockIndex = i;
                                        var block = blocks[i];
                                        var isCompleted = courseProgress?.CompletedBlocks.Contains(blockIndex) ?? false;
                                        var isCurrent = blockIndex == CurrentBlockIndex;
                                        var isNavigationAllowed = CanNavigateToBlock(blockIndex);
                                        var isQuizInReadOnlyMode = IsReadOnlyMode && block.Type == "questionnaire";

                                        <div class="list-group-item @(isCurrent ? "active" : "") @(!isNavigationAllowed ? "disabled" : "") p-2"
                                             @onclick="() => HandleBlockNavigation(blockIndex)"
                                             role="button"
                                             style="@(!isNavigationAllowed ? "cursor: not-allowed; opacity: 0.6;" : "cursor: pointer;")">
                                            <div class="d-flex justify-content-between align-items-center">
                                                <span class="@(isCurrent ? "fw-bold" : "")">
                                                    @(blockIndex + 1). @(!string.IsNullOrEmpty(block.Title) ? block.Title : GetBlockTypeDisplay(block.Type))
                                                </span>
                                                <div class="d-flex align-items-center">
                                                    @if (isQuizInReadOnlyMode)
                                                    {
                                                        <i class="bi bi-eye-slash-fill text-warning me-2" title="Quiz non accessible en mode consultation"></i>
                                                    }
                                                    else if (!isNavigationAllowed && !isCurrent)
                                                    {
                                                        <i class="bi bi-lock-fill text-muted me-2" title="Bloc verrouillé - terminez le cours une fois pour débloquer"></i>
                                                    }
                                                    @if (isCompleted)
                                                    {
                                                        <i class="bi bi-check-circle-fill text-success"></i>
                                                    }
                                                    else if (isCurrent)
                                                    {
                                                        <i class="bi bi-arrow-right text-primary"></i>
                                                    }
                                                </div>
                                            </div>
                                        </div>
                                    }
                                </div>
                                @if (IsReadOnlyMode)
                                {
                                    <div class="alert alert-info mt-3 mb-0">
                                        <i class="bi bi-info-circle me-2"></i>
                                        <small>
                                            <strong>Mode consultation :</strong> Vous pouvez consulter uniquement les blocs de texte. Les questionnaires ne sont pas accessibles.
                                        </small>
                                    </div>
                                }
                                else if (!HasCompletedCourseOnce())
                                {
                                    <div class="alert alert-info mt-3 mb-0">
                                        <i class="bi bi-info-circle me-2"></i>
                                        <small>
                                            <strong>Navigation séquentielle :</strong> Vous devez suivre les blocs dans l'ordre jusqu'à la fin du cours.
                                            Une fois terminé, vous pourrez naviguer librement entre tous les blocs.
                                        </small>
                                    </div>
                                }
                            </div>
                        }
                    </div>
                </div>
            </div>
        </div>

        <!-- Contenu principal du bloc -->
        <div class="row">
            <div class="col-12">
                <div class="card shadow-sm">
                    @if (showNavigationHelper && !CanNavigateToNext() && IsCurrentBlockQuiz())
                    {
                        <div class="alert alert-warning alert-dismissible fade show m-3">
                            <i class="bi bi-exclamation-triangle me-2"></i>
                            <strong>Information :</strong> Vous devez compléter ce quiz pour continuer vers le bloc suivant.
                            <button type="button" class="btn-close" @onclick="() => showNavigationHelper = false"></button>
                        </div>
                    }

                    <div class="card-body">
                        @if (IsCurrentBlockValid())
                        {
                            var currentBlock = blocks![CurrentBlockIndex];
                            <div class="course-block-viewer">
                                <DynamicComponent Type="@GetViewerBlockComponent(currentBlock.Type)"
                                                  Parameters="@GetViewerBlockParameters(currentBlock)" />
                            </div>
                        }
                        else
                        {
                            <div class="alert alert-info text-center">
                                <i class="bi bi-info-circle me-2 fs-3"></i>
                                <h5>Cours en construction</h5>
                                <p class="mb-0">Ce cours ne contient pas encore de contenu. Revenez plus tard !</p>
                            </div>
                        }
                    </div>

                    <!-- Pied de page avec navigation -->
                    <div class="card-footer bg-light">
                        <div class="d-flex justify-content-between align-items-center">
                            <div class="navigation-left">
                                @if (CurrentBlockIndex > 0)
                                {
                                    <button class="btn btn-outline-secondary" @onclick="GoToPreviousBlock">
                                        <i class="bi bi-arrow-left me-1"></i>
                                        Précédent
                                    </button>
                                }
                            </div>

                            <div class="navigation-center">
                                @if (IsLastBlock() && courseProgress?.IsCompleted == true)
                                {
                                    <div class="alert alert-success mb-0">
                                        <i class="bi bi-trophy-fill me-2"></i>
                                        <strong>Cours terminé avec succès !</strong>
                                    </div>
                                }
                            </div>

                            <div class="navigation-right">
                                @if (CurrentBlockIndex < (blocks?.Count ?? 0) - 1)
                                {
                                    <button class="btn @(CanNavigateToNext() ? "btn-primary" : "btn-outline-primary disabled")"
                                            @onclick="GoToNextBlock"
                                            disabled="@(!CanNavigateToNext())">
                                        Suivant
                                        <i class="bi bi-arrow-right ms-1"></i>
                                    </button>
                                }
                                else if (courseProgress?.IsCompleted == true)
                                {
                                    <button class="btn btn-outline-secondary" @onclick="RetourVersListe">
                                        <i class="bi bi-list me-1"></i>
                                        Retour aux cours
                                    </button>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
}


@code {
    [Parameter] public int CoursId { get; set; }
    [Parameter] public int? BlockIndex { get; set; }

    // **NOUVEAU: Paramètre pour le mode lecture seule**
    [SupplyParameterFromQuery(Name = "readonly")]
    public bool IsReadOnlyMode { get; set; }

    private Cours? cours;
    private List<CourBuilder.CoursBlock>? blocks;
    private bool isLoading = true;
    private bool showNavigationHelper = true;

    // ✅ Propriété sécurisée pour CurrentBlockIndex
    private int CurrentBlockIndex => BlockIndex ?? 0;

    private Services.CourseProgress? courseProgress;
    private Dictionary<int, bool> quizCompletionState = new();

    // Ajout d'un token de cancellation pour éviter les opérations après disposal
    private CancellationTokenSource? _cancellationTokenSource;

    // Flag pour éviter les redirections multiples
    private bool _isNavigating = false;

    protected override async Task OnInitializedAsync()
    {
        _cancellationTokenSource = new CancellationTokenSource();

        try
        {
            await LoadCoursData(_cancellationTokenSource.Token);
            await LoadCourseProgress(_cancellationTokenSource.Token);
        }
        catch (OperationCanceledException)
        {
            // Le composant a été disposé, ignorer
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de l'initialisation: {ex.Message}");
        }
    }

    private async Task LoadCoursData(CancellationToken cancellationToken = default)
    {
        try
        {
            // ✅ Créer et disposer le contexte dans le même scope
            await using var context = await DbContextFactory.CreateDbContextAsync(cancellationToken);

            cours = await context.Courses
                .Include(c => c.Session)
                .FirstOrDefaultAsync(c => c.Id == CoursId, cancellationToken);

            if (cours != null && !string.IsNullOrEmpty(cours.Content))
            {
                try
                {
                    blocks = System.Text.Json.JsonSerializer.Deserialize<List<CourBuilder.CoursBlock>>(
                        cours.Content,
                        new System.Text.Json.JsonSerializerOptions
                        {
                            PropertyNameCaseInsensitive = true
                        });

                    blocks ??= new List<CourBuilder.CoursBlock>();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Erreur lors de la désérialisation des blocs: {ex.Message}");
                    blocks = new List<CourBuilder.CoursBlock>();
                }
            }
            else
            {
                blocks = new List<CourBuilder.CoursBlock>();
            }
        }
        catch (OperationCanceledException)
        {
            // Opération annulée, ne pas traiter comme une erreur
            throw;
        }
        catch (ObjectDisposedException)
        {
            Console.WriteLine("DbContext disposé - opération annulée");
            blocks = new List<CourBuilder.CoursBlock>();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du chargement du cours: {ex.Message}");
            blocks = new List<CourBuilder.CoursBlock>();
        }
        finally
        {
            isLoading = false;
        }
    }

    // Ajoutez cette méthode utilitaire dans la section @code
    private bool IsCurrentBlockValid()
    {
        return blocks != null && CurrentBlockIndex >= 0 && CurrentBlockIndex < blocks.Count;
    }

    private async Task LoadCourseProgress(CancellationToken cancellationToken = default)
    {
        try
        {
            if (cancellationToken.IsCancellationRequested) return;
            courseProgress = await CourseStateService.GetOrCreateProgressAsync(CoursId);
        }
        catch (OperationCanceledException)
        {
            // Composant disposé
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du chargement du progrès: {ex.Message}");
        }
    }

    private async Task GoToNextBlock()
    {
        if (!CanNavigateToNext())
        {
            if (IsCurrentBlockQuiz())
            {
                await JSRuntime.InvokeVoidAsync("alert", "Vous devez compléter ce quiz pour continuer.");
            }
            return;
        }

        // Marquer le bloc actuel comme complété (sauf en mode readonly)
        if (!IsReadOnlyMode && courseProgress != null && !courseProgress.CompletedBlocks.Contains(CurrentBlockIndex))
        {
            await MarkBlockAsCompleted();
        }

        if (CurrentBlockIndex < (blocks?.Count ?? 0) - 1)
        {
            var nextIndex = CurrentBlockIndex + 1;

            // **NOUVEAU: En mode readonly, sauter les questionnaires**
            if (IsReadOnlyMode)
            {
                while (nextIndex < blocks!.Count && blocks[nextIndex].Type == "questionnaire")
                {
                    nextIndex++;
                }

                // Si on a dépassé la fin, rester sur le bloc actuel
                if (nextIndex >= blocks.Count)
                {
                    await JSRuntime.InvokeVoidAsync("alert",
                        "Il n'y a plus de blocs de texte disponibles. Les questionnaires ne sont pas accessibles en mode consultation.");
                    return;
                }
            }

            NavigationManager.NavigateTo(GetBlockUrl(nextIndex));
        }
    }

    private async Task GoToPreviousBlock()
    {
        if (CurrentBlockIndex > 0)
        {
            var prevIndex = CurrentBlockIndex - 1;

            // **NOUVEAU: En mode readonly, sauter les questionnaires**
            if (IsReadOnlyMode)
            {
                while (prevIndex >= 0 && blocks![prevIndex].Type == "questionnaire")
                {
                    prevIndex--;
                }

                // Si on est revenu au début, rester sur le bloc actuel
                if (prevIndex < 0)
                {
                    await JSRuntime.InvokeVoidAsync("alert",
                        "Il n'y a plus de blocs de texte disponibles avant celui-ci.");
                    return;
                }
            }

            NavigationManager.NavigateTo(GetBlockUrl(prevIndex));
        }
    }

    private async Task GoToBlock(int blockIndex)
    {
        // ✅ CORRECTION: Vérifier si le bloc est accessible avant la navigation
        if (!CanNavigateToBlock(blockIndex))
        {
            // Si c'est un questionnaire en mode readonly, afficher un message
            if (IsReadOnlyMode && blocks != null && blockIndex < blocks.Count && blocks[blockIndex].Type == "questionnaire")
            {
                await JSRuntime.InvokeVoidAsync("alert",
                    "Les questionnaires ne sont pas accessibles en mode consultation. " +
                    "Seuls les blocs de texte peuvent être consultés.");
            }
            return;
        }

        if (blockIndex >= 0 && blockIndex < (blocks?.Count ?? 0))
        {
            NavigationManager.NavigateTo(GetBlockUrl(blockIndex));
        }
    }


    private async Task MarkBlockAsCompleted()
    {
        if (courseProgress != null && IsCurrentBlockValid())
        {
            courseProgress.CompletedBlocks.Add(CurrentBlockIndex);

            // Vérifier si le cours est complété
            if (blocks != null && courseProgress.CompletedBlocks.Count >= blocks.Count)
            {
                courseProgress.IsCompleted = true;
            }

            await CourseStateService.SaveProgressAsync(courseProgress);
            StateHasChanged();
        }
    }

    private async Task CompleteCourse()
    {
        if (courseProgress == null || blocks == null) return;

        try
        {
            // Marquer le dernier bloc comme complété s'il ne l'est pas
            if (IsCurrentBlockValid() && !courseProgress.CompletedBlocks.Contains(CurrentBlockIndex))
            {
                courseProgress.CompletedBlocks.Add(CurrentBlockIndex);
            }

            // Marquer le cours comme terminé
            courseProgress.IsCompleted = true;

            await CourseStateService.SaveProgressAsync(courseProgress);

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de la completion du cours: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("alert", "Une erreur s'est produite lors de la completion du cours.");
        }
    }

    // ✅ Méthodes utilitaires sécurisées
    private bool IsLastBlock()
    {
        return blocks != null && blocks.Any() && CurrentBlockIndex == blocks.Count - 1;
    }

    private bool IsCurrentBlockCompleted()
    {
        return courseProgress?.CompletedBlocks.Contains(CurrentBlockIndex) ?? false;
    }

    private bool CanCompleteCourse()
    {
        if (!IsCurrentBlockValid() || courseProgress == null) return false;

        var currentBlock = blocks![CurrentBlockIndex];

        // Si ce n'est pas un quiz, permettre la completion
        if (currentBlock.Type != "quiz") return true;

        // Si c'est un quiz, vérifier s'il est complété
        return quizCompletionState.ContainsKey(CurrentBlockIndex) && quizCompletionState[CurrentBlockIndex];
    }

    private bool CanNavigateToNext()
    {
        if (!IsCurrentBlockValid()) return false;

        var currentBlock = blocks![CurrentBlockIndex];

        // Si ce n'est pas un quiz, permettre la navigation
        if (currentBlock.Type != "quiz") return true;

        // Si c'est un quiz, vérifier s'il est complété
        return quizCompletionState.ContainsKey(CurrentBlockIndex) && quizCompletionState[CurrentBlockIndex];
    }

    private bool IsCurrentBlockQuiz()
    {
        if (!IsCurrentBlockValid()) return false;
        return blocks![CurrentBlockIndex].Type == "quiz";
    }

    private async Task OnQuizCompleted(bool isCorrect)
    {
        // Marquer le quiz comme complété
        quizCompletionState[CurrentBlockIndex] = true;

        // Enregistrer l'interaction du quiz
        if (courseProgress != null)
        {
            var quizInteraction = new
            {
                completed = true,
                correct = isCorrect,
                timestamp = DateTime.UtcNow
            };
            courseProgress.BlockInteractions[CurrentBlockIndex.ToString()] = System.Text.Json.JsonSerializer.Serialize(quizInteraction);

            // ✅ Vérifier si tous les questionnaires du cours sont complétés
            if (AreAllQuizCompleted())
            {
                // Terminer automatiquement le cours
                await CompleteCourse();
            }
            else
            {
                await CourseStateService.SaveProgressAsync(courseProgress);
            }
        }

        StateHasChanged();
    }

    // ✅ Nouvelle méthode pour vérifier si tous les questionnaires sont complétés
    private bool AreAllQuizCompleted()
    {
        if (blocks == null || !blocks.Any()) return false;

        // Récupérer tous les blocs de type questionnaire
        var quizBlocks = blocks
            .Select((block, index) => new { Block = block, Index = index })
            .Where(x => x.Block.Type == "questionnaire")
            .ToList();

        // Si aucun questionnaire, on ne peut pas terminer automatiquement
        if (!quizBlocks.Any()) return false;

        // Vérifier que tous les questionnaires sont complétés
        return quizBlocks.All(q => quizCompletionState.ContainsKey(q.Index) && quizCompletionState[q.Index]);
    }

    private void RetourVersListe()
    {
        var sessionId = cours?.SessionId;
        var url = sessionId.HasValue ? $"/session/{sessionId.Value}" : "/Manager/Cours";
        NavigationManager.NavigateTo(url);
    }

    private string GetBlockUrl(int blockIndex)
    {
        // ✅ CORRECTION: Préserver le paramètre readonly dans l'URL
        var baseUrl = $"/Cours/View/{CoursId}/Block/{blockIndex}";
        return IsReadOnlyMode ? $"{baseUrl}?readonly=true" : baseUrl;
    }

    private string GetCurrentBlockTitle()
    {
        if (!IsCurrentBlockValid())
            return "Contenu du cours";

        var currentBlock = blocks![CurrentBlockIndex];
        return !string.IsNullOrEmpty(currentBlock.Title)
            ? currentBlock.Title
            : $"Bloc {CurrentBlockIndex + 1}";
    }

    private string GetBlockTypeDisplay(String type) => type switch
    {
        "texte" => "Contenu textuel",
        "quiz" => "Quiz",
        _ => "Contenu"
    };

    private Type GetViewerBlockComponent(string type) => type switch
    {
        "texte" => typeof(TextBlockViewer),
        "questionnaire" => typeof(QuestionnaireBlockViewer), // Changé de "quiz"
        _ => typeof(TextBlockViewer)
    };

    private Dictionary<string, object> GetViewerBlockParameters(CourBuilder.CoursBlock block)
    {
        var parameters = new Dictionary<string, object>
        {
            ["Block"] = block,
            // **MODIFIÉ: Activer le mode lecture seule si IsReadOnlyMode est true OU si c'est un questionnaire**
            ["IsReadOnly"] = IsReadOnlyMode || block.Type == "questionnaire"
        };

        // Pour les questionnaires
        if (block.Type == "questionnaire")
        {
            parameters["CoursId"] = CoursId;
            parameters["OnQuizCompleted"] = EventCallback.Factory.Create<bool>(this, OnQuizCompleted);
        }

        return parameters;
    }

    private int GetCorrectAnswersCount()
    {
        if (courseProgress?.BlockInteractions == null) return 0;

        int correctCount = 0;
        foreach (var interaction in courseProgress.BlockInteractions)
        {
            try
            {
                using var document = System.Text.Json.JsonDocument.Parse(interaction.Value);
                if (document.RootElement.TryGetProperty("correct", out var correctProperty) &&
                    correctProperty.GetBoolean())
                {
                    correctCount++;
                }
            }
            catch
            {
                // Ignorer les interactions mal formées
            }
        }

        return correctCount;
    }

    private int GetCompletedQuizCount()
    {
        if (courseProgress?.BlockInteractions == null) return 0;

        int completedCount = 0;
        foreach (var interaction in courseProgress.BlockInteractions)
        {
            try
            {
                using var document = System.Text.Json.JsonDocument.Parse(interaction.Value);
                if (document.RootElement.TryGetProperty("completed", out var completedProperty) &&
                    completedProperty.GetBoolean())
                {
                    completedCount++;
                }
            }
            catch
            {
                // Ignorer les interactions mal formées
            }
        }

        return completedCount;
    }

    private int GetTotalQuizCount()
    {
        if (blocks == null) return 0;
        return blocks.Count(b => b.Type == "quiz");
    }

    // Vérifie si l'utilisateur peut naviguer vers un bloc spécifique
    private bool CanNavigateToBlock(int targetBlockIndex)
    {
        // ✅ Vérification de sécurité
        if (blocks == null || targetBlockIndex < 0 || targetBlockIndex >= blocks.Count)
            return false;

        // **NOUVEAU: En mode lecture seule, permettre seulement l'accès aux blocs de texte**
        if (IsReadOnlyMode)
        {
            var targetBlock = blocks[targetBlockIndex];
            // Bloquer l'accès aux questionnaires en mode readonly
            if (targetBlock.Type == "questionnaire")
            {
                return false;
            }
            // Autoriser tous les autres blocs
            return true;
        }

        // Si le cours a déjà été complété une fois, autoriser la navigation libre
        if (HasCompletedCourseOnce())
        {
            return true;
        }

        // Sinon, navigation séquentielle uniquement
        // Permettre d'aller au bloc actuel
        if (targetBlockIndex == CurrentBlockIndex)
        {
            return true;
        }

        // Permettre d'aller au bloc suivant si le bloc actuel permet la navigation
        if (targetBlockIndex == CurrentBlockIndex + 1 && CanNavigateToNext())
        {
            return true;
        }

        // Permettre d'aller aux blocs précédents déjà visités
        if (targetBlockIndex < CurrentBlockIndex)
        {
            return true;
        }

        return false;
    }

    // Vérifie si le cours a été complété au moins une fois
    private bool HasCompletedCourseOnce()
    {
        // Vérifier si le cours est actuellement marqué comme complété
        if (courseProgress?.IsCompleted == true)
        {
            return true;
        }

        // Vérifier si tous les blocs ont été complétés au moins une fois
        if (blocks != null && courseProgress?.CompletedBlocks != null)
        {
            return courseProgress.CompletedBlocks.Count >= blocks.Count;
        }

        return false;
    }

    // Gère la navigation vers un bloc avec vérification des permissions
    private async Task HandleBlockNavigation(int blockIndex)
    {
        if (!CanNavigateToBlock(blockIndex))
        {
            // **NOUVEAU: Message spécifique pour les quiz en mode readonly**
            if (IsReadOnlyMode && blocks != null && blockIndex < blocks.Count && blocks[blockIndex].Type == "questionnaire")
            {
                await JSRuntime.InvokeVoidAsync("alert",
                    "Les questionnaires ne sont pas accessibles en mode consultation. " +
                    "Seuls les blocs de texte peuvent être consultés.");
                return; // ✅ CORRECTION: Retour ajouté ici
            }

            await JSRuntime.InvokeVoidAsync("alert",
                "Navigation bloquée : Vous devez suivre les blocs dans l'ordre jusqu'à la fin du cours. " +
                "Une fois le cours terminé, vous pourrez naviguer librement entre tous les blocs.");
            return; // ✅ Ce retour était déjà présent
        }

        await GoToBlock(blockIndex);
    }

    protected override async Task OnParametersSetAsync()
    {
        // ✅ Éviter les opérations si le composant est en cours de destruction
        if (_cancellationTokenSource?.IsCancellationRequested == true) return;

        // ✅ Éviter les redirections multiples
        if (_isNavigating) return;

        // ✅ Attendre que les données soient chargées avant de valider les paramètres
        if (isLoading) return;

        try
        {
            _isNavigating = true;

            // Rediriger vers le dernier bloc consulté si aucun bloc spécifié
            if (!BlockIndex.HasValue && blocks != null && blocks.Any())
            {
                var targetBlock = courseProgress?.LastAccessedBlock ?? 0;

                // ✅ CORRECTION: En mode readonly, trouver le premier bloc non-questionnaire
                if (IsReadOnlyMode)
                {
                    targetBlock = 0;
                    while (targetBlock < blocks.Count && blocks[targetBlock].Type == "questionnaire")
                    {
                        targetBlock++;
                    }

                    // Si tous les blocs sont des questionnaires, afficher un message
                    if (targetBlock >= blocks.Count)
                    {
                        await JSRuntime.InvokeVoidAsync("alert",
                            "Ce cours ne contient que des questionnaires qui ne sont pas accessibles en mode consultation.");
                        NavigationManager.NavigateTo($"/session/{cours?.SessionId}");
                        return;
                    }
                }

                targetBlock = Math.Max(0, Math.Min(targetBlock, blocks.Count - 1));
                NavigationManager.NavigateTo(GetBlockUrl(targetBlock), replace: true);
                return;
            }

            // ✅ CORRECTION: Vérifier que le bloc actuel n'est pas un questionnaire en mode readonly
            if (BlockIndex.HasValue && IsReadOnlyMode && blocks != null &&
                BlockIndex.Value >= 0 && BlockIndex.Value < blocks.Count)
            {
                if (blocks[BlockIndex.Value].Type == "questionnaire")
                {
                    // Trouver le bloc de texte le plus proche
                    var alternativeBlock = FindNearestTextBlock(BlockIndex.Value);

                    if (alternativeBlock >= 0)
                    {
                        await JSRuntime.InvokeVoidAsync("alert",
                            "Le questionnaire n'est pas accessible en mode consultation. " +
                            "Vous avez été redirigé vers un bloc de texte.");
                        NavigationManager.NavigateTo(GetBlockUrl(alternativeBlock), replace: true);
                        return;
                    }
                    else
                    {
                        await JSRuntime.InvokeVoidAsync("alert",
                            "Ce cours ne contient que des questionnaires qui ne sont pas accessibles en mode consultation.");
                        NavigationManager.NavigateTo($"/session/{cours?.SessionId}");
                        return;
                    }
                }
            }

            // Vérifier que l'index est valide
            if (BlockIndex.HasValue && blocks != null &&
                (BlockIndex.Value < 0 || BlockIndex.Value >= blocks.Count))
            {
                var safeIndex = Math.Max(0, Math.Min(BlockIndex.Value, blocks.Count - 1));
                NavigationManager.NavigateTo(GetBlockUrl(safeIndex), replace: true);
                return;
            }

            // Sauvegarder l'accès au bloc actuel (sauf en mode readonly sur un questionnaire)
            if (BlockIndex.HasValue && courseProgress != null && IsCurrentBlockValid() && !IsReadOnlyMode)
            {
                courseProgress.LastAccessedBlock = BlockIndex.Value;
                await CourseStateService.SaveProgressAsync(courseProgress);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur dans OnParametersSetAsync: {ex.Message}");
        }
        finally
        {
            _isNavigating = false;
        }
    }

    // Implémentation de IAsyncDisposable pour nettoyer les ressources
    public async ValueTask DisposeAsync()
    {
        try
        {
            _cancellationTokenSource?.Cancel();
            _cancellationTokenSource?.Dispose();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du nettoyage: {ex.Message}");
        }
    }

    // **NOUVELLE MÉTHODE: Vérifie si un bloc est un questionnaire**
    private bool IsBlockTypeQuiz(int blockIndex)
    {
        if (blocks == null || blockIndex < 0 || blockIndex >= blocks.Count)
            return false;

        return blocks[blockIndex].Type == "questionnaire";
    }

    private int FindNearestTextBlock(int currentIndex)
    {
        if (blocks == null || blocks.Count == 0) return -1;

        // Chercher vers le bas d'abord
        for (int i = currentIndex + 1; i < blocks.Count; i++)
        {
            if (blocks[i].Type != "questionnaire")
            {
                return i;
            }
        }

        // Chercher vers le haut
        for (int i = currentIndex - 1; i >= 0; i--)
        {
            if (blocks[i].Type != "questionnaire")
            {
                return i;
            }
        }

        return -1; // Aucun bloc de texte trouvé
    }
}