@page "/manager/session"

@rendermode InteractiveServer
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Authorization
@using Microsoft.Extensions.Logging
@using Mooc.Data
@using Microsoft.EntityFrameworkCore
@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Components.Forms
@using Mooc.Services
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject NavigationManager NavigationManager
@inject FileUploadService FileUploadService
@inject ILogger<SessionManager> Logger
@inject IJSRuntime JSRuntime
@attribute [Authorize(Policy = "GestionFormation")]
@attribute [StreamRendering]

<PageTitle>Gestion des Sessions</PageTitle>

<!-- En-tête de page avec design moderne -->
<div class="page-header header-waves ocean header-animated">
    <div class="container">
        <div class="row align-items-center">
            <div class="col">
                <i class="bi bi-calendar-week header-icon morphing"></i>
                <h1 class="page-title typewriter">Gestion des Sessions</h1>
                <p class="page-subtitle">Créez et gérez vos sessions de formation</p>
            </div>
            <div class="col-auto">
                <button class="btn btn-primary btn-lg session-create-btn" @onclick="ShowCreateSessionModal">
                    <i class="bi bi-plus-circle me-2"></i>
                    Nouvelle Session
                </button>
            </div>
        </div>
    </div>
</div>

<div class="container mt-4">
    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger" role="alert">
            <div class="d-flex align-items-center">
                <i class="bi bi-exclamation-triangle-fill me-2"></i>
                <div class="flex-grow-1">
                    <strong>Erreur:</strong> @errorMessage
                </div>
                <button class="btn btn-sm btn-outline-danger ms-2" @onclick="ClearError">
                    <i class="bi bi-x"></i>
                </button>
            </div>
        </div>
    }

    @if (sessions != null)
    {
        @if (sessions.Any())
        {
            <!-- Vue en cartes pour un meilleur design -->
            <div class="sessions-grid">
                @foreach (var session in sessions)
                {
                    <div class="session-card">
                        <div class="session-image">
                            @if (!string.IsNullOrEmpty(session.Image))
                            {
                                <img src="@session.Image" alt="@session.Title" />
                            }
                            else
                            {
                                <div class="session-image-placeholder">
                                    <i class="bi bi-image"></i>
                                </div>
                            }
                            <div class="session-status">
                                <span class="bage @GetSessionStatusClass(session)">
                                    <i class="bi @GetSessionStatusIcon(session)"> </i> @GetSessionStatusText(session)
                                </span>

                                <span class="bage bg-secondary">
                                    <i class="bi bi-people-fill text-info me-2"></i>
                                    @GetEnrolledCount(session.Id) inscrit@(GetEnrolledCount(session.Id) > 1 ? "s" : "")
                                    @if (IsCountUpdating(session.Id))
                                    {
                                        <span class="spinner-border spinner-border-sm ms-1" style="width: 0.75rem; height: 0.75rem;"></span>
                                    }
                                </span>

                                <!-- Badge cours -->
                                <span class="bage @(GetPublishedCoursesCount(session.Id) > 0 ? "bg-info" : "bg-warning")">
                                    <i class="bi bi-book me-1"></i>
                                    @GetPublishedCoursesCount(session.Id) cours@(GetPublishedCoursesCount(session.Id) > 1 ? "s" : "")
                                </span>
                            </div>
                        </div>
                        
                        <div class="session-content">
                            <h5 class="session-title">@session.Title</h5>
                            <p class="session-description">
                                @(session.Description?.Length > 100 ? session.Description.Substring(0, 100) + "..." : session.Description)
                            </p>
                            
                            <div class="session-meta">
                                <div class="session-date">
                                    <i class="bi bi-calendar3 me-1"></i>
                                    <small>@session.StartDate.ToString("dd/MM/yyyy") - @session.EndDate.ToString("dd/MM/yyyy")</small>
                                </div>
                                <div class="session-work">
                                    <i class="bi bi-clock me-1"></i>
                                    <small>@session.Work heures</small>
                                </div>
                            </div>
                        </div>

                        <!-- **SECTION ACTIONS RESTAURÉE** -->
                        <div class="session-actions">
                            <div class="btn-group w-100" role="group">
                                <button class="btn btn-outline-primary @(HasUsersEnrolled(session.Id) ? "disabled" : "")" 
                                        @onclick="() => EditSession(session.Id)" 
                                        disabled="@HasUsersEnrolled(session.Id)"
                                        title="@(HasUsersEnrolled(session.Id) ? "Modification bloquée : des utilisateurs sont inscrits" : "Modifier")">
                                    <i class="bi bi-pencil"></i>    
                                </button>
                                <button class="btn @(session.IsActive ? "btn-success" : "btn-outline-secondary")" 
                                        @onclick="() => ToggleSessionStatus(session.Id)" 
                                        title="@(session.IsActive ? "Désactiver" : "Activer")">
                                    <i class="bi @(session.IsActive ? "bi-toggle-on" : "bi-toggle-off")"></i>
                                </button>
                                @if (HasUsersEnrolled(session.Id))
                                {
                                    <span class="btn btn-info disabled" 
                                          title="Gestion des cours bloquée : des utilisateurs sont inscrits">
                                        <i class="bi bi-book"></i>
                                    </span>
                                }
                                else
                                {
                                    <a class="btn btn-info" href="/Manager/Cours?sessionId=@session.Id" title="Gérer les cours">
                                        <i class="bi bi-book"></i>
                                    </a>
                                }
                                <button class="btn btn-outline-danger @(HasUsersEnrolled(session.Id) ? "disabled" : "")" 
                                        @onclick="() => DeleteSessionConfirmation(session.Id)" 
                                        disabled="@HasUsersEnrolled(session.Id)"
                                        title="@(HasUsersEnrolled(session.Id) ? "Suppression bloquée : des utilisateurs sont inscrits" : "Supprimer")">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                }
            </div>
        }
        else
        {
            <!-- État vide amélioré -->
            <div class="empty-state">
                <div class="empty-state-icon">
                    <i class="bi bi-calendar-x"></i>
                </div>
                <h3 class="empty-state-title">Aucune session créée</h3>
                <p class="empty-state-text">Créez votre première session de formation pour commencer.</p>
                <button class="btn btn-primary btn-lg" @onclick="ShowCreateSessionModal">
                    <i class="bi bi-plus-circle me-2"></i>
                    Créer ma première session
                </button>
            </div>
        }
    }
    else
    {
        <!-- Loading state amélioré -->
        <div class="loading-state">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Chargement...</span>
            </div>
            <p class="mt-3">Chargement des sessions...</p>
        </div>
    }
</div>

<!-- Modal amélioré -->
@if (showModal)
{
    <div class="modal fade show modal-backdrop-custom" style="display: block;" aria-modal="true" role="dialog">
        <div class="modal-dialog modal-lg modal-dialog-centered">
            <div class="modal-content modal-modern">
                <div class="modal-header modal-header-modern">
                    <h5 class="modal-title">
                        <i class="bi @(isEditing ? "bi-pencil-square" : "bi-plus-circle") me-2"></i>
                        @modalTitle
                    </h5>
                    <button type="button" class="btn-close" @onclick="CloseModal"></button>
                </div>
                <div class="modal-body">
                    @if (!string.IsNullOrEmpty(formErrorMessage))
                    {
                        <div class="alert alert-danger" role="alert">
                            @formErrorMessage
                        </div>
                    }
                    
                    <EditForm Model="@sessionModel" OnValidSubmit="HandleValidSubmit">
                        <DataAnnotationsValidator />

                        <div class="row">
                            <div class="col-md-8">
                                <div class="form-floating mb-3">
                                    <InputText @bind-Value="sessionModel.Title" class="form-control" placeholder="Titre de la session" />
                                    <label>Titre de la session</label>
                                    <ValidationMessage For="@(() => sessionModel.Title)" />
                                </div>
                                
                                <div class="form-floating mb-3">
                                    <InputTextArea @bind-Value="sessionModel.Description" class="form-control" style="height: 120px" placeholder="Description" />
                                    <label>Description</label>
                                    <ValidationMessage For="@(() => sessionModel.Description)" />
                                </div>
                            </div>
                            
                            <div class="col-md-4">
                                <div class="image-upload-section">
                                    <label class="form-label">Image de la session</label>
                                    <div class="image-preview">
                                        @if (!string.IsNullOrEmpty(previewImageUrl))
                                        {
                                            <!-- **NOUVEAU** : Affichage de la prévisualisation de l'image sélectionnée -->
                                            <img src="@previewImageUrl" alt="Aperçu de l'image sélectionnée" />
                                            <div class="image-overlay">
                                                <span class="badge bg-success">
                                                    <i class="bi bi-check-circle me-1"></i>
                                                    Nouvelle image sélectionnée
                                                </span>
                                            </div>
                                        }
                                        else if (!string.IsNullOrEmpty(sessionModel.Image))
                                        {
                                            <!-- Image existante (en mode édition) -->
                                            <img src="@sessionModel.Image" alt="Aperçu" />
                                        }
                                        else
                                        {
                                            <!-- Placeholder quand aucune image -->
                                            <div class="image-placeholder">
                                                <i class="bi bi-image"></i>
                                                <p>Aucune image</p>
                                            </div>
                                        }
                                    </div>
                                    <InputFile OnChange="OnImageFileSelected" class="form-control mt-2" accept=".jpg,.jpeg,.png,.gif" />
                                    <small class="text-muted">JPG, PNG, GIF. Max: 3MB</small>
                                    
                                    @if (!string.IsNullOrEmpty(previewImageUrl))
                                    {
                                        <div class="mt-2">
                                            <button type="button" class="btn btn-sm btn-outline-secondary" @onclick="ClearImageSelection">
                                                <i class="bi bi-x-circle me-1"></i>
                                                Annuler la sélection
                                            </button>
                                        </div>
                                    }
                                </div>
                            </div>  
                        </div>
                        
                        <div class="row mt-1">
                            <div class="col-md-6">
                                <div class="form-floating mb-3">
                                    <InputDate @bind-Value="sessionModel.StartDate" class="form-control" />
                                    <label>Date de début</label>
                                    <ValidationMessage For="@(() => sessionModel.StartDate)" />
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-floating mb-3">
                                    <InputDate @bind-Value="sessionModel.EndDate" class="form-control" />
                                    <label>Date de fin</label>
                                    <ValidationMessage For="@(() => sessionModel.EndDate)" />
                                </div>
                            </div>
                        </div>
                        
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-floating mb-3">
                                    <InputNumber @bind-Value="sessionModel.Work" class="form-control" />
                                    <label>Durée (heures)</label>
                                    <ValidationMessage For="@(() => sessionModel.Work)" />
                                </div>
                            </div>
                        </div>

                        <div class="modal-footer">
                            <button type="button" class="btn btn-outline-secondary" @onclick="CloseModal">
                                <i class="bi bi-x-circle me-1"></i>
                                Annuler
                            </button>
                            <button type="submit" class="btn btn-primary">
                                <i class="bi @(isEditing ? "bi-check-circle" : "bi-plus-circle") me-1"></i>
                                @(isEditing ? "Modifier" : "Créer")
                            </button>
                        </div>
                    </EditForm>
                </div>
            </div>
        </div>
    </div>
}

@if (showDeleteConfirmation)
{
    <div class="modal fade show modal-backdrop-custom" style="display: block;" aria-modal="true" role="dialog">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content modal-modern">
                <div class="modal-header modal-header-danger">
                    <h5 class="modal-title">
                        <i class="bi bi-exclamation-triangle me-2"></i>
                        Confirmer la suppression
                    </h5>
                    <button type="button" class="btn-close btn-close-white" @onclick="() => showDeleteConfirmation = false"></button>
                </div>
                <div class="modal-body text-center">
                    <div class="delete-icon mb-3">
                        <i class="bi bi-trash3"></i>
                    </div>
                    <p class="lead">Êtes-vous sûr de vouloir supprimer cette session ?</p>
                    <p class="text-muted">Cette action est irréversible.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline-secondary" @onclick="() => showDeleteConfirmation = false">
                        <i class="bi bi-x-circle me-1"></i>
                        Annuler
                    </button>
                    <button type="button" class="btn btn-danger" @onclick="ConfirmDeleteSession">
                        <i class="bi bi-trash me-1"></i>
                        Supprimer définitivement
                    </button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    // Variables existantes
    private List<Mooc.Data.Session>? sessions;
    private SessionModel sessionModel = new();
    private bool showModal = false;
    private string modalTitle = "Créer une session";
    private bool isEditing = false;
    private int currentSessionId = 0;
    private bool showDeleteConfirmation = false;
    private IBrowserFile? selectedImageFile;
    private string? oldImagePath;

    // **NOUVEAU** : Variable pour la prévisualisation
    private string? previewImageUrl;

    private Dictionary<int, int> enrolledCounts = new();
    private HashSet<int> updatingCounts = new();

    // **NOUVEAU** : Cache pour les cours publiés
    private Dictionary<int, int> publishedCoursesCache = new();

    // Variables d'erreur simplifiées
    private string? errorMessage;
    private string? formErrorMessage;

    // **NOUVEAU** : Token d'annulation pour gérer les timeouts
    private CancellationTokenSource? cancellationTokenSource;

    protected override async Task OnInitializedAsync()
    {
        await LoadSessionsWithErrorHandling();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Initialiser le gestionnaire d'images
            await JSRuntime.InvokeVoidAsync("ImageHandler.initializeAllImages");
        }
    }

    // **OPTIMISÉ** : Méthode de chargement avec gestion de timeout améliorée
    private async Task LoadSessionsWithErrorHandling()
    {
        try
        {
            // Annuler toute opération en cours
            cancellationTokenSource?.Cancel();
            cancellationTokenSource = new CancellationTokenSource();

            // Définir un timeout de 30 secondes
            cancellationTokenSource.CancelAfter(TimeSpan.FromSeconds(30));

            await LoadSessionsOptimized(cancellationTokenSource.Token);
        }
        catch (OperationCanceledException)
        {
            errorMessage = "L'opération a pris trop de temps. Veuillez réessayer.";
        }
        catch (Exception ex)
        {
            errorMessage = $"Erreur lors du chargement des sessions : {ex.Message}";
        }
    }

    // **NOUVELLE** : Méthode optimisée qui charge tout en une seule fois
    // ⭐ CORRECTION : Créer un nouveau DbContext pour chaque opération
    private async Task LoadSessionsOptimized(CancellationToken cancellationToken = default)
    {
        using var context = await DbContextFactory.CreateDbContextAsync(cancellationToken);

        // Vérification immédiate des sessions expirées avant l'affichage
        await CheckAndUpdateExpiredSessions(context, cancellationToken);

        // Charger les sessions
        sessions = await context.Sessions.AsNoTracking().ToListAsync(cancellationToken);

        if (sessions?.Any() == true)
        {
            var sessionIds = sessions.Select(s => s.Id).ToList();

            // ⭐ CORRECTION : Utiliser un nouveau contexte pour les compteurs
            await LoadAllCountsOptimized(sessionIds, cancellationToken);
        }
    }

    // ⭐ CORRECTION : Séparer la logique des compteurs avec son propre contexte
    private async Task LoadAllCountsOptimized(List<int> sessionIds, CancellationToken cancellationToken)
    {
        try
        {
            using var context = await DbContextFactory.CreateDbContextAsync(cancellationToken);

            // Charger les compteurs d'inscriptions en une seule requête
            var enrollmentCounts = await context.Sessions
                .Where(s => sessionIds.Contains(s.Id))
                .Select(s => new
                {
                    SessionId = s.Id,
                    Count = s.EnrolledUsers.Count()
                })
                .AsNoTracking()
                .ToListAsync(cancellationToken);

            enrolledCounts.Clear();
            foreach (var item in enrollmentCounts)
            {
                enrolledCounts[item.SessionId] = item.Count;
            }

            // Charger les compteurs de cours publiés
            var courseCounts = await context.Courses
                .Where(c => sessionIds.Contains(c.SessionId) && c.IsPublished)
                .GroupBy(c => c.SessionId)
                .Select(g => new { SessionId = g.Key, Count = g.Count() })
                .AsNoTracking()
                .ToListAsync(cancellationToken);

            publishedCoursesCache.Clear();
            
            // **NOUVEAU** : Charger les sessions avec des utilisateurs inscits ou pré-inscrits
            var sessionsWithEnrolledUsers = await context.Sessions
                .Where(s => sessionIds.Contains(s.Id) && s.EnrolledUsers.Any())
                .AsNoTracking()
                .Select(s => s.Id)
                .ToListAsync(cancellationToken);
                
            var sessionsWithPreRegistrations = await context.PreRegistrations
                .Where(pr => sessionIds.Contains(pr.SessionId) && pr.Status == "Active")
                .AsNoTracking()
                .Select(pr => pr.SessionId)
                .Distinct()
                .ToListAsync(cancellationToken);
            
            sessionsWithUsersCache.Clear();
            foreach (var sessionId in sessionIds)
            {
                var courseCount = courseCounts.FirstOrDefault(cc => cc.SessionId == sessionId);
                publishedCoursesCache[sessionId] = courseCount?.Count ?? 0;

                // Initialiser le compteur d'inscriptions si pas trouvé
                if (!enrolledCounts.ContainsKey(sessionId))
                {
                    enrolledCounts[sessionId] = 0;
                }
                
                // **NOUVEAU** : Marquer les sessions avec des utilisateurs
                sessionsWithUsersCache[sessionId] = sessionsWithEnrolledUsers.Contains(sessionId) || 
                                                   sessionsWithPreRegistrations.Contains(sessionId);
            }
        }
        catch (Exception ex)
        {
            // En cas d'erreur, initialiser avec des valeurs par défaut
            foreach (var sessionId in sessionIds)
            {
                enrolledCounts.TryAdd(sessionId, 0);
                publishedCoursesCache.TryAdd(sessionId, 0);
                sessionsWithUsersCache.TryAdd(sessionId, false);
            }

            Logger?.LogError(ex, "Erreur lors du chargement des compteurs");
        }
    }

    // **OPTIMISÉ** : Méthode avec timeout
    private async Task CheckAndUpdateExpiredSessions(ApplicationDbContext context, CancellationToken cancellationToken = default)
    {
        var now = DateTime.Now;
        var expiredSessions = await context.Sessions
            .Where(s => s.IsActive && s.EndDate < now)
            .ToListAsync(cancellationToken);

        if (expiredSessions.Any())
        {
            foreach (var session in expiredSessions)
            {
                session.IsActive = false;
            }

            await context.SaveChangesAsync(cancellationToken);
        }
    }
    private async Task ToggleSessionEditor(int sessionId)

    {
        try
        {
            using var context = await DbContextFactory.CreateDbContextAsync();
        }
        catch
        {
            
        }
    }

    private async Task ToggleSessionStatus(int sessionId)
    {
        try
        {
            var now = DateTime.Now;

            using var context = await DbContextFactory.CreateDbContextAsync();
            var session = await context.Sessions.Include(s => s.Courses).FirstOrDefaultAsync(s => s.Id == sessionId);

            if (session != null)
            {
                // Vérification : bloquer l'activation si aucun cours n'existe
                if (!session.IsActive && (session.Courses == null || !session.Courses.Any()))
                {
                    errorMessage = "Impossible de publier cette session : aucun cours n'a été créé. Veuillez d'abord ajouter des cours à cette session.";
                    return;
                }

                // Vérification : bloquer l'activation s'il n'y a pas de cours publiés
                if (!session.IsActive && session.Courses != null && !session.Courses.Any(c => c.IsPublished))
                {
                    errorMessage = "Impossible de publier  cette session : aucun cours n'est publié. Veuillez publier au moins un cours avant d'activer la session.";
                    return;
                }

                // Vérification : Session terminé
                if (session.EndDate < now)
                {
                    errorMessage = "Impossible de publier  cette session : la période de formation est expirée";
                    return;
                }

                session.IsActive = !session.IsActive;
                await context.SaveChangesAsync();

                // **OPTIMISÉ** : Recharger seulement si nécessaire
                await LoadSessionsOptimized();
                ClearError();
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Erreur lors du changement de statut : {ex.Message}";
        }
    }

    private void ShowCreateSessionModal()
    {
        sessionModel = new SessionModel();
        selectedImageFile = null;
        previewImageUrl = null;
        oldImagePath = null;
        modalTitle = "Créer une session";
        isEditing = false;
        showModal = true;
        formErrorMessage = null;
    }

    private async Task EditSession(int sessionId)
    {
        try
        {
            // **NOUVEAU** : Vérifier s'il y a des utilisateurs inscrits ou pré-inscrits
            if (await HasEnrolledOrPreRegisteredUsers(sessionId))
            {
                errorMessage = "Impossible de modifier cette session : des utilisateurs sont inscrits ou pré-inscrits. La modification est bloquée pour préserver l'intégrité des données.";
                return;
            }

            using var context = await DbContextFactory.CreateDbContextAsync();
            var session = await context.Sessions.FindAsync(sessionId);

            if (session != null)
            {
                currentSessionId = sessionId;
                oldImagePath = session.Image;
                previewImageUrl = null;
                sessionModel = new SessionModel
                {
                    Title = session.Title,
                    Image = session.Image ?? string.Empty,
                    Description = session.Description ?? string.Empty,
                    StartDate = session.StartDate,
                    EndDate = session.EndDate,
                    Work = session.Work,
                    IsActive = session.IsActive
                };

                modalTitle = "Modifier la session";
                isEditing = true;
                showModal = true;
                selectedImageFile = null;
                formErrorMessage = null;
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Erreur lors du chargement de la session : {ex.Message}";
        }
    }

    private async Task OnImageFileSelected(InputFileChangeEventArgs e)
    {
        selectedImageFile = e.File;

        try
        {
            if (!selectedImageFile.ContentType.StartsWith("image/"))
            {
                formErrorMessage = "Le fichier doit être une image.";
                selectedImageFile = null;
                previewImageUrl = null;
                return;
            }

            if (selectedImageFile.Size > 3 * 1024 * 1024)
            {
                formErrorMessage = "La taille de l'image ne doit pas dépasser 3MB.";
                selectedImageFile = null;
                previewImageUrl = null;
                return;
            }

            // ⭐ CORRECTION : Lecture sécurisée et complète du fichier
            const int maxBufferSize = 3 * 1024 * 1024; // 3MB
            byte[] buffer;
            
            using (var stream = selectedImageFile.OpenReadStream(maxBufferSize))
            {
                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                buffer = memoryStream.ToArray();
                
                // ⭐ Vérification de l'intégrité
                if (buffer.Length == 0)
                {
                    formErrorMessage = "Erreur : Le fichier semble vide ou corrompu.";
                    selectedImageFile = null;
                    previewImageUrl = null;
                    return;
                }
            }

            // ⭐ Validation de la signature de l'image avant preview
            if (!IsValidImageSignature(buffer, selectedImageFile.ContentType))
            {
                formErrorMessage = "Le fichier sélectionné n'est pas une image valide.";
                selectedImageFile = null;
                previewImageUrl = null;
                return;
            }

            var base64String = Convert.ToBase64String(buffer);
            previewImageUrl = $"data:{selectedImageFile.ContentType};base64,{base64String}";

            formErrorMessage = null;
            StateHasChanged();

            // Initialiser le redimensionnement automatique après la mise à jour
            await Task.Delay(100);
            await JSRuntime.InvokeVoidAsync("ImageHandler.initializeAllImages");
        }
        catch (Exception ex)
        {
            Logger?.LogError(ex, "Erreur lors de la sélection de l'image");
            formErrorMessage = "Erreur lors de la lecture du fichier. Veuillez réessayer avec une autre image.";
            selectedImageFile = null;
            previewImageUrl = null;
        }
    }

    private void DeleteSessionConfirmation(int sessionId)
    {
        currentSessionId = sessionId;
        showDeleteConfirmation = true;
    }

    private async Task ConfirmDeleteSession()
    {
        try
        {
            using var context = await DbContextFactory.CreateDbContextAsync();
            var session = await context.Sessions.FindAsync(currentSessionId);

            if (session != null)
            {
                if (!string.IsNullOrEmpty(session.Image) && session.Image.StartsWith("/uploads/"))
                {
                    FileUploadService.DeleteFile(session.Image);
                }

                context.Sessions.Remove(session);
                await context.SaveChangesAsync();

                // **OPTIMISÉ** : Recharger seulement si nécessaire
                await LoadSessionsOptimized();
                ClearError();
            }

            showDeleteConfirmation = false;
        }
        catch (Exception ex)
        {
            errorMessage = $"Erreur lors de la suppression : {ex.Message}";
            showDeleteConfirmation = false;
        }
    }

    private async Task HandleValidSubmit()
    {
        try
        {
            string imagePath = sessionModel.Image;

            if (selectedImageFile != null)
            {
                imagePath = await FileUploadService.UploadImageAsync(selectedImageFile);
            }

            using var context = await DbContextFactory.CreateDbContextAsync();

            if (isEditing)
            {
                var session = await context.Sessions.FindAsync(currentSessionId);

                if (session != null)
                {
                    session.Title = sessionModel.Title;

                    if (selectedImageFile != null && !string.IsNullOrEmpty(oldImagePath) && oldImagePath.StartsWith("/uploads/"))
                    {
                        FileUploadService.DeleteFile(oldImagePath);
                    }

                    session.Image = imagePath;
                    session.Description = sessionModel.Description;
                    session.StartDate = sessionModel.StartDate;
                    session.EndDate = sessionModel.EndDate ?? DateTime.Today.AddDays(30);
                    session.Work = sessionModel.Work;
                    session.IsActive = false;

                    await context.SaveChangesAsync();
                }
            }
            else
            {
                var session = new Mooc.Data.Session
                {
                    Title = sessionModel.Title,
                    Image = imagePath,
                    Description = sessionModel.Description,
                    StartDate = sessionModel.StartDate,
                    EndDate = sessionModel.EndDate ?? DateTime.Today.AddDays(30),
                    Work = sessionModel.Work,
                    IsActive = false
                };

                context.Sessions.Add(session);
                await context.SaveChangesAsync();
            }

            // **OPTIMISÉ** : Recharger seulement si nécessaire
            await LoadSessionsOptimized();
            CloseModal();
            ClearError();
        }
        catch (Exception ex)
        {
            formErrorMessage = $"Erreur lors de l'enregistrement : {ex.Message}";
        }
    }

    private void ClearImageSelection()
    {
        selectedImageFile = null;
        previewImageUrl = null;
        formErrorMessage = null;
        StateHasChanged();
    }

    // **OPTIMISÉE** : Méthode synchrone pour obtenir le nombre de cours publiés
    private int GetPublishedCoursesCount(int sessionId)
    {
        return publishedCoursesCache.TryGetValue(sessionId, out var count) ? count : 0;
    }

    private void ClearError()
    {
        errorMessage = null;
        formErrorMessage = null;
    }

    private int GetEnrolledCount(int sessionId)
    {
        return enrolledCounts.TryGetValue(sessionId, out var count) ? count : 0;
    }

    private void CloseModal()
    {
        showModal = false;
        selectedImageFile = null;
        previewImageUrl = null;
        formErrorMessage = null;
    }

    private bool IsCountUpdating(int sessionId)
    {
        return updatingCounts.Contains(sessionId);
    }

    // **NOUVEAU** : Nettoyer les ressources
    public void Dispose()
    {
        cancellationTokenSource?.Cancel();
        cancellationTokenSource?.Dispose();
    }

    private class SessionModel
    {
        [Required(ErrorMessage = "Le titre est requis")]
        [StringLength(200, ErrorMessage = "Le titre ne doit pas dépasser 200 caractères")]
        public string Title { get; set; } = string.Empty;

        public string Image { get; set; } = string.Empty;

        [Required(ErrorMessage = "La description est requise")]
        public string Description { get; set; } = string.Empty;

        [Required(ErrorMessage = "La date de début est requise")]
        public DateTime StartDate { get; set; } = DateTime.Today;

        [Required(ErrorMessage = "La date de fin est requise")]
        public DateTime? EndDate { get; set; } = DateTime.Today.AddDays(30);

        [Required(ErrorMessage = "Le temps de travail est requis")]
        [Range(1, 1000, ErrorMessage = "Le temps de travail doit être entre 1 et 1000 heures")]
        public int Work { get; set; } = 10;

        public bool IsActive { get; set; } = false;
    }

    private string GetSessionStatusClass(Mooc.Data.Session session)
    {
        var now = DateTime.Now;

        if (now > session.EndDate)
            return "bg-secondary"; // Session terminée

        if (!session.IsActive)
            return "bg-danger"; // Hors ligne manuellement

        return "bg-success"; // En ligne
    }

    private string GetSessionStatusIcon(Mooc.Data.Session session)
    {
        var now = DateTime.Now;

        if (now > session.EndDate)
            return "bi-clock-history"; // Session terminée

        if (!session.IsActive)
            return "bi bi-wifi-off"; // Hors ligne

        return "bi bi-wifi"; // En ligne
    }

    private string GetSessionStatusText(Mooc.Data.Session session)
    {
        var now = DateTime.Now;

        if (now > session.EndDate)
            return "Terminée";

        if (!session.IsActive)
            return "Hors ligne";

        return "En ligne";
    }

    private async Task<bool> CanActivateSession(int sessionId)
    {
        try
        {
            using var context = await DbContextFactory.CreateDbContextAsync();
            var session = await context.Sessions.Include(s => s.Courses).FirstOrDefaultAsync(s => s.Id == sessionId);

            if (session == null) return false;

            // Vérifier s'il y a des cours publiés
            return session.Courses != null && session.Courses.Any(c => c.IsPublished);
        }
        catch
        {
            return false;
        }
    }

    private bool IsValidImageSignature(byte[] buffer, string contentType)
    {
        // Vérification simple des signatures pour PNG, JPEG, GIF
        if (buffer == null || buffer.Length < 4)
            return false;

        // PNG : 89 50 4E 47
        if (contentType.Contains("png") && buffer.Length >= 4 &&
            buffer[0] == 0x89 && buffer[1] == 0x50 && buffer[2] == 0x4E && buffer[3] == 0x47)
            return true;

        // JPEG : FF D8 FF
        if (contentType.Contains("jpeg") || contentType.Contains("jpg"))
        {
            if (buffer.Length >= 3 && buffer[0] == 0xFF && buffer[1] == 0xD8 && buffer[2] == 0xFF)
                return true;
        }

        // GIF : 47 49 46 38
        if (contentType.Contains("gif") && buffer.Length >= 4 &&
            buffer[0] == 0x47 && buffer[1] == 0x49 && buffer[2] == 0x46 && buffer[3] == 0x38)
            return true;

        return false;
    }

    // Méthode pour vérifier si une session a des utilisateurs inscrits ou pré-inscrits
    private async Task<bool> HasEnrolledOrPreRegisteredUsers(int sessionId)
    {
        try
        {
            using var context = await DbContextFactory.CreateDbContextAsync();
            
            // Vérifier s'il y a des utilisateurs inscrits
            var hasEnrolledUsers = await context.Sessions
                .Where(s => s.Id == sessionId)
                .AnyAsync(s => s.EnrolledUsers.Any());
            
            if (hasEnrolledUsers)
                return true;
                
            // Vérifier s'il y a des pré-inscriptions actives
            var hasPreRegistrations = await context.PreRegistrations
                .AnyAsync(pr => pr.SessionId == sessionId && pr.Status == "Active");
                
            return hasPreRegistrations;
        }
        catch (Exception ex)
        {
            Logger?.LogError(ex, "Erreur lors de la vérification des inscriptions pour la session {SessionId}", sessionId);
            return false; // En cas d'erreur, on autorise la modification
        }
    }

    // Cache pour stocker l'état des sessions avec inscriptions
    private Dictionary<int, bool> sessionsWithUsersCache = new();

    // Méthode pour obtenir l'état depuis le cache ou calculer
    private bool HasUsersEnrolled(int sessionId)
    {
        return sessionsWithUsersCache.TryGetValue(sessionId, out var hasUsers) && hasUsers;
    }
}