@using Microsoft.AspNetCore.Components.Web
@using Mooc.Services
@inherits ErrorBoundary
@inject IErrorHandlingService ErrorHandlingService
@inject ILogger<GlobalErrorBoundary> Logger
@inject IJSRuntime JSRuntime

@if (CurrentException is null)
{
    @ChildContent
}
else
{
    <div class="error-boundary-container">
        <div class="alert alert-danger" role="alert">
            <h4 class="alert-heading">
                <i class="bi bi-exclamation-triangle me-2"></i>
                Une erreur inattendue s'est produite
            </h4>
            <p>L'application a rencontré une erreur technique. Nos équipes ont été automatiquement notifiées.</p>
            <hr>
            <div class="d-flex gap-2">
                <button class="btn btn-primary" @onclick="NavigateToErrorPage">
                    <i class="bi bi-info-circle me-1"></i>
                    Voir les détails
                </button>
                <button class="btn btn-outline-secondary" @onclick="RecoverFromError">
                    <i class="bi bi-arrow-clockwise me-1"></i>
                    Réessayer
                </button>
                <button class="btn btn-outline-primary" @onclick="GoHome">
                    <i class="bi bi-house me-1"></i>
                    Retour à l'accueil
                </button>
            </div>
        </div>
    </div>
}

@code {
    [Inject] private NavigationManager NavigationManager { get; set; } = default!;
    
    private int _errorCount = 0;
    private readonly TimeSpan _errorCooldown = TimeSpan.FromMinutes(1);
    private DateTime _lastErrorTime = DateTime.MinValue;

    protected override async Task OnErrorAsync(Exception exception)
    {
        try
        {
            _errorCount++;
            _lastErrorTime = DateTime.Now;

            // Enrichir les informations d'erreur
            var errorContext = new
            {
                ErrorId = Guid.NewGuid(),
                Timestamp = DateTime.UtcNow,
                UserAgent = await GetUserAgent(),
                Url = NavigationManager.Uri,
                UserId = await GetCurrentUserId(),
                ErrorCount = _errorCount,
                ExceptionType = exception.GetType().Name,
                Message = exception.Message,
                StackTrace = exception.StackTrace
            };

            // Log structuré
            Logger.LogError(exception, 
                "ErrorBoundary captured exception {ErrorId}. Count: {ErrorCount}, Type: {ExceptionType}, Message: {Message}, Context: {@ErrorContext}",
                errorContext.ErrorId, _errorCount, exception.GetType().Name, exception.Message, errorContext);

            // Notification côté client pour le debugging
            if (Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") == "Development")
            {
                await JSRuntime.InvokeVoidAsync("console.error", "ErrorBoundary Exception:", exception.ToString());
            }

            await Task.CompletedTask;
        }
        catch (Exception loggingException)
        {
            // Fallback si même le logging échoue
            Console.WriteLine($"Critical error in ErrorBoundary logging: {loggingException}");
        }
    }

    private void NavigateToErrorPage()
    {
        try
        {
            ErrorHandlingService.NavigateToError(CurrentException!, "Erreur capturée par le système de gestion d'erreurs");
        }
        catch
        {
            // Fallback si le service échoue
            NavigationManager.NavigateTo("/Error", true);
        }
    }

    private new void RecoverFromError()
    {
        try
        {
            // Vérifier si on peut récupérer (éviter les boucles infinies)
            if (_errorCount > 3 || (DateTime.Now - _lastErrorTime) < _errorCooldown)
            {
                // Trop d'erreurs récentes, rediriger vers la page d'erreur
                NavigateToErrorPage();
                return;
            }

            // Réinitialiser l'ErrorBoundary
            base.Recover();
        }
        catch
        {
            GoHome();
        }
    }

    private void GoHome()
    {
        NavigationManager.NavigateTo("/", true);
    }

    private async Task<string> GetUserAgent()
    {
        try
        {
            return await JSRuntime.InvokeAsync<string>("eval", "navigator.userAgent");
        }
        catch
        {
            return "Unknown";
        }
    }

    private async Task<string> GetCurrentUserId()
    {
        try
        {
            // Récupérer l'ID utilisateur depuis le contexte d'authentification
            return await JSRuntime.InvokeAsync<string>("eval", "window.userId || 'Anonymous'");
        }
        catch
        {
            return "Unknown";
        }
    }
}